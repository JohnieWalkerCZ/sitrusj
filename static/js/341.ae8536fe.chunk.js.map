{"version":3,"file":"static/js/341.ae8536fe.chunk.js","mappings":"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","sources":["../node_modules/@jitl/quickjs-ffi-types/src/ffi-types.ts","../node_modules/quickjs-emscripten-core/src/debug.ts","../node_modules/quickjs-emscripten-core/src/errors.ts","../node_modules/quickjs-emscripten-core/src/asyncify-helpers.ts","../node_modules/quickjs-emscripten-core/src/lifetime.ts","../node_modules/quickjs-emscripten-core/src/deferred-promise.ts","../node_modules/quickjs-emscripten-core/src/memory.ts","../node_modules/quickjs-emscripten-core/src/types.ts","../node_modules/quickjs-emscripten-core/src/context.ts","../node_modules/quickjs-emscripten-core/src/runtime.ts","../node_modules/quickjs-emscripten-core/src/module.ts","../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../node_modules/quickjs-emscripten-core/src/from-variant.ts","../node_modules/quickjs-emscripten-core/src/module-test.ts","../node_modules/@jitl/quickjs-wasmfile-release-asyncify/src/index.ts","../node_modules/quickjs-emscripten/src/variants.ts","worker.js","../node_modules/quickjs-emscripten-core/src/interrupt-helpers.ts"],"sourcesContent":["/**\n * C pointer to type `CType`. Pointer types are used internally for FFI, but\n * are not intended for external use.\n *\n * @unstable This type is considered private and may change.\n */\ntype Pointer<CType extends string> = number & { ctype: CType }\n\ntype Brand<T, B> = T & { brand: B }\n\n/**\n * `JSRuntime*`.\n */\nexport type JSRuntimePointer = Pointer<\"JSRuntime\">\n\n/**\n * `JSContext*`.\n */\nexport type JSContextPointer = Pointer<\"JSContext\">\n\n/**\n * `JSContext**`. Used internally for execute pending jobs.\n */\nexport type JSContextPointerPointer = Pointer<\"JSContext\">\n\n/**\n * `JSModuleDef*`.\n */\nexport type JSModuleDefPointer = Pointer<\"JSModuleDef\">\n\n/**\n * `JSValue*`.\n * See {@link JSValue}.\n */\nexport type JSValuePointer = Pointer<\"JSValue\">\n\n/**\n * `JSValueConst*\n * See {@link JSValueConst} and {@link StaticJSValue}.\n */\nexport type JSValueConstPointer = Pointer<\"JSValueConst\">\n\n/**\n * Used internally for Javascript-to-C function calls.\n */\nexport type JSValuePointerPointer = Pointer<\"JSValue[]\">\n\n/**\n * Used internally for Javascript-to-C function calls.\n */\nexport type JSValueConstPointerPointer = Pointer<\"JSValueConst[]\">\n\n/**\n * Used internally for C-to-Javascript function calls.\n */\n// type JSCFunctionPointer = Pointer<'JSCFunction'>\n\n/**\n * Used internally for C-to-Javascript function calls.\n */\nexport type QTS_C_To_HostCallbackFuncPointer = Pointer<\"C_To_HostCallbackFunc\">\n\n/**\n * Used internally for C-to-Javascript interrupt handlers.\n */\nexport type QTS_C_To_HostInterruptFuncPointer = Pointer<\"C_To_HostInterruptFunc\">\n\n/**\n * Used internally for C-to-Javascript module loading.\n */\nexport type QTS_C_To_HostLoadModuleFuncPointer = Pointer<\"C_To_HostLoadModuleFunc\">\n\n/**\n * Used internally for Javascript-to-C calls that may contain strings too large\n * for the Emscripten stack.\n */\nexport type BorrowedHeapCharPointer = Pointer<\"const char\" | \"char\" | \"js const char\">\n\n/**\n * Used internally for Javascript-to-C calls that may contain strings too large\n * for the Emscripten stack.\n */\nexport type OwnedHeapCharPointer = Pointer<\"char\">\n\n/**\n * Used internally for Javascript-to-C calls that may contain strings too large\n * for the Emscripten stack.\n */\nexport type JSBorrowedCharPointer = Pointer<\"js const char\">\n\n/**\n * Opaque pointer that was allocated by js_malloc.\n */\nexport type JSVoidPointer = Pointer<any>\n\n/**\n * @private\n */\nexport type EvalFlags = Brand<number, \"EvalFlags\">\n\n/**\n * @private\n */\nexport type IntrinsicsFlags = Brand<number, \"IntrinsicsFlags\">\n\n/**\n * @private\n */\nexport type EvalDetectModule = Brand<number, \"EvalDetectModule\">\n\n/**\n * State of a promise.\n */\nexport type JSPromiseStateEnum = Brand<\n  (typeof JSPromiseStateEnum)[keyof typeof JSPromiseStateEnum],\n  \"JSPromiseStateEnum\"\n>\n\nexport function assertSync<Args extends any[], R>(fn: (...args: Args) => R): (...args: Args) => R {\n  return function mustBeSync(...args: Args): R {\n    const result = fn(...args)\n    if (result && typeof result === \"object\" && result instanceof Promise) {\n      throw new Error(\"Function unexpectedly returned a Promise\")\n    }\n    return result\n  }\n}\n\n/** Bitfield options for JS_Eval() C function. */\nexport const EvalFlags = {\n  /** global code (default) */\n  JS_EVAL_TYPE_GLOBAL: 0 << 0,\n  /** module code */\n  JS_EVAL_TYPE_MODULE: 1 << 0,\n  /** direct call (internal use) */\n  JS_EVAL_TYPE_DIRECT: 2 << 0,\n  /** indirect call (internal use) */\n  JS_EVAL_TYPE_INDIRECT: 3 << 0,\n  JS_EVAL_TYPE_MASK: 3 << 0,\n  /** force 'strict' mode */\n  JS_EVAL_FLAG_STRICT: 1 << 3,\n  /** force 'strip' mode */\n  JS_EVAL_FLAG_STRIP: 1 << 4,\n  /**\n   * compile but do not run. The result is an object with a\n   * JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed\n   * with JS_EvalFunction().\n   */\n  JS_EVAL_FLAG_COMPILE_ONLY: 1 << 5,\n  /** don't include the stack frames before this eval in the Error() backtraces */\n  JS_EVAL_FLAG_BACKTRACE_BARRIER: 1 << 6,\n} as const\n\n/** Bitfield options for QTS_NewContext intrinsices */\nexport const IntrinsicsFlags = {\n  BaseObjects: 1 << 0,\n  Date: 1 << 1,\n  Eval: 1 << 2,\n  StringNormalize: 1 << 3,\n  RegExp: 1 << 4,\n  RegExpCompiler: 1 << 5,\n  JSON: 1 << 6,\n  Proxy: 1 << 7,\n  MapSet: 1 << 8,\n  TypedArrays: 1 << 9,\n  Promise: 1 << 10,\n  BigInt: 1 << 11,\n  BigFloat: 1 << 12,\n  BigDecimal: 1 << 13,\n  OperatorOverloading: 1 << 14,\n  BignumExt: 1 << 15,\n} as const\n\nexport const JSPromiseStateEnum = {\n  Pending: 0,\n  Fulfilled: 1,\n  Rejected: 2,\n} as const\n","/**\n * @private\n * Mutable variable. Use {@link setDebugMode} to enable.\n */\nexport let QTS_DEBUG = false\n\n/**\n * Enable (or disable) debug logging and object creation tracking in the Javascript API.\n * To get debug logging in the WebAssembly module, you need to use a debug build variant.\n */\nexport function setDebugMode(enabled: boolean = true) {\n  QTS_DEBUG = enabled\n}\n\n/**\n * @private\n */\nexport function debugLog(...args: any[]) {\n  if (QTS_DEBUG) {\n    console.log(...args)\n  }\n}\n","import type { QuickJSContext } from \"./context\"\n\n/**\n * Error thrown if {@link QuickJSContext#unwrapResult} unwraps an error value that isn't an object.\n */\nexport class QuickJSUnwrapError extends Error {\n  name = \"QuickJSUnwrapError\"\n  constructor(\n    public cause: unknown,\n    public context?: QuickJSContext,\n  ) {\n    super(String(cause))\n  }\n}\n\nexport class QuickJSWrongOwner extends Error {\n  name = \"QuickJSWrongOwner\"\n}\n\nexport class QuickJSUseAfterFree extends Error {\n  name = \"QuickJSUseAfterFree\"\n}\n\nexport class QuickJSNotImplemented extends Error {\n  name = \"QuickJSNotImplemented\"\n}\n\nexport class QuickJSAsyncifyError extends Error {\n  name = \"QuickJSAsyncifyError\"\n}\n\nexport class QuickJSAsyncifySuspended extends Error {\n  name = \"QuickJSAsyncifySuspended\"\n}\n\nexport class QuickJSMemoryLeakDetected extends Error {\n  name = \"QuickJSMemoryLeakDetected\"\n}\n\nexport class QuickJSEmscriptenModuleError extends Error {\n  name = \"QuickJSEmscriptenModuleError\"\n}\n\nexport class QuickJSUnknownIntrinsic extends TypeError {\n  name = \"QuickJSUnknownIntrinsic\"\n}\n\nexport class QuickJSPromisePending extends Error {\n  name = \"QuickJSPromisePending\"\n}\n","function* awaitYield<T>(value: T | Promise<T>) {\n  return (yield value) as T\n}\n\nfunction awaitYieldOf<T, Yielded>(\n  generator: Generator<Yielded | Promise<Yielded>, T, Yielded>,\n): Generator<T | Promise<T>, T, T> {\n  return awaitYield(awaitEachYieldedPromise(generator))\n}\n\nexport type AwaitYield = typeof awaitYield & {\n  of: typeof awaitYieldOf\n}\n\nconst AwaitYield: AwaitYield = awaitYield as AwaitYield\nAwaitYield.of = awaitYieldOf\n\n/**\n * Create a function that may or may not be async, using a generator\n *\n * Within the generator, call `yield* awaited(maybePromise)` to await a value\n * that may or may not be a promise.\n *\n * If the inner function never yields a promise, it will return synchronously.\n */\nexport function maybeAsyncFn<\n  /** Function arguments */\n  Args extends any[],\n  This,\n  /** Function return type */\n  Return,\n  /** Yields to unwrap */\n  Yielded,\n>(\n  that: This,\n  fn: (\n    this: This,\n    awaited: AwaitYield,\n    ...args: Args\n  ) => Generator<Yielded | Promise<Yielded>, Return, Yielded>,\n): (...args: Args) => Return | Promise<Return> {\n  return (...args: Args) => {\n    const generator = fn.call(that, AwaitYield, ...args)\n    return awaitEachYieldedPromise(generator)\n  }\n}\n\n// class Example {\n//   private maybeAsyncMethod = maybeAsyncFn(this, function* (awaited, a: number) {\n//     yield* awaited(new Promise((resolve) => setTimeout(resolve, a)))\n//     return 5\n//   })\n// }\n\nexport type MaybeAsyncBlock<Return, This, Yielded, Args extends any[] = []> = (\n  this: This,\n  awaited: AwaitYield,\n  ...args: Args\n) => Generator<Yielded | Promise<Yielded>, Return, Yielded>\n\nexport function maybeAsync<Return, This, Yielded>(\n  that: This,\n  startGenerator: (\n    this: This,\n    await: AwaitYield,\n  ) => Generator<Yielded | Promise<Yielded>, Return, Yielded>,\n): Return | Promise<Return> {\n  const generator = startGenerator.call(that, AwaitYield)\n  return awaitEachYieldedPromise(generator)\n}\n\nexport function awaitEachYieldedPromise<Yielded, Returned>(\n  gen: Generator<Yielded | Promise<Yielded>, Returned, Yielded>,\n): Returned | Promise<Returned> {\n  type NextResult = ReturnType<typeof gen.next>\n\n  function handleNextStep(step: NextResult): Returned | Promise<Returned> {\n    if (step.done) {\n      return step.value\n    }\n\n    if (step.value instanceof Promise) {\n      return step.value.then(\n        (value) => handleNextStep(gen.next(value)),\n        (error) => handleNextStep(gen.throw(error)),\n      )\n    }\n\n    return handleNextStep(gen.next(step.value))\n  }\n\n  return handleNextStep(gen.next())\n}\n","import type { MaybeAsyncBlock } from \"./asyncify-helpers\"\nimport { maybeAsync } from \"./asyncify-helpers\"\nimport { QTS_DEBUG } from \"./debug\"\nimport { QuickJSUseAfterFree } from \"./errors\"\nimport type { QuickJSHandle } from \"./types\"\n\n/**\n * An object that can be disposed.\n * {@link Lifetime} is the canonical implementation of Disposable.\n * Use {@link Scope} to manage cleaning up multiple disposables.\n */\nexport interface Disposable {\n  /**\n   * Dispose of the underlying resources used by this object.\n   */\n  dispose(): void\n\n  /**\n   * @returns true if the object is alive\n   * @returns false after the object has been {@link dispose}d\n   */\n  alive: boolean\n\n  /**\n   * A method that is used to release resources held by an object. Called by the semantics of the `using` statement.\n   */\n  [Symbol.dispose](): void\n}\n\n/**\n * Base abstract class that helps implement {@link Disposable} by providing a default implementation of {@link Symbol.dispose}.\n */\nexport abstract class UsingDisposable implements Disposable {\n  /**\n   * @returns true if the object is alive\n   * @returns false after the object has been {@link dispose}d\n   */\n  declare abstract readonly alive: boolean\n  /**\n   * Dispose of the underlying resources used by this object.\n   */\n  abstract dispose(): void\n  /**\n   * Just calls the standard .dispose() method of this class.\n   */\n  [Symbol.dispose]() {\n    return this.dispose()\n  }\n}\n\n// Polyfill as needed if Symbol.dispose is not available.\n// This polyfill matches ESBuild's behavior.\nconst SymbolDispose = Symbol.dispose ?? Symbol.for(\"Symbol.dispose\")\nconst prototypeAsAny = UsingDisposable.prototype as any\nif (!prototypeAsAny[SymbolDispose]) {\n  prototypeAsAny[SymbolDispose] = function () {\n    return this.dispose()\n  }\n}\n\n/**\n * A lifetime prevents access to a value after the lifetime has been\n * {@link dispose}ed.\n *\n * Typically, quickjs-emscripten uses Lifetimes to protect C memory pointers.\n */\nexport class Lifetime<T, TCopy = never, Owner = never>\n  extends UsingDisposable\n  implements Disposable\n{\n  protected _alive: boolean = true\n  protected _constructorStack = QTS_DEBUG ? new Error(\"Lifetime constructed\").stack : undefined\n\n  /**\n   * When the Lifetime is disposed, it will call `disposer(_value)`. Use the\n   * disposer function to implement whatever cleanup needs to happen at the end\n   * of `value`'s lifetime.\n   *\n   * `_owner` is not used or controlled by the lifetime. It's just metadata for\n   * the creator.\n   */\n  constructor(\n    protected readonly _value: T,\n    protected readonly copier?: (value: T | TCopy) => TCopy,\n    protected readonly disposer?: (value: T | TCopy) => void,\n    protected readonly _owner?: Owner,\n  ) {\n    super()\n  }\n\n  get alive() {\n    return this._alive\n  }\n\n  /**\n   * The value this Lifetime protects. You must never retain the value - it\n   * may become invalid, leading to memory errors.\n   *\n   * @throws If the lifetime has been {@link dispose}d already.\n   */\n  get value() {\n    this.assertAlive()\n    return this._value\n  }\n\n  get owner() {\n    return this._owner\n  }\n\n  get dupable() {\n    return !!this.copier\n  }\n\n  /**\n   * Create a new handle pointing to the same {@link value}.\n   */\n  dup() {\n    this.assertAlive()\n    if (!this.copier) {\n      throw new Error(\"Non-dupable lifetime\")\n    }\n    return new Lifetime<TCopy, TCopy, Owner>(\n      this.copier(this._value),\n      this.copier,\n      this.disposer,\n      this._owner,\n    )\n  }\n\n  /**\n   * Call `map` with this lifetime, then dispose the lifetime.\n   * @return the result of `map(this)`.\n   */\n  consume<O>(map: (lifetime: this) => O): O\n  // A specific type definition is needed for our common use-case\n  // https://github.com/microsoft/TypeScript/issues/30271\n  consume<O>(map: (lifetime: QuickJSHandle) => O): O\n  consume<O>(map: (lifetime: any) => O): O {\n    this.assertAlive()\n    const result = map(this)\n    this.dispose()\n    return result\n  }\n\n  /**\n   * Dispose of {@link value} and perform cleanup.\n   */\n  dispose() {\n    this.assertAlive()\n    if (this.disposer) {\n      this.disposer(this._value)\n    }\n    this._alive = false\n  }\n\n  private assertAlive() {\n    if (!this.alive) {\n      if (this._constructorStack) {\n        throw new QuickJSUseAfterFree(\n          `Lifetime not alive\\n${this._constructorStack}\\nLifetime used`,\n        )\n      }\n      throw new QuickJSUseAfterFree(\"Lifetime not alive\")\n    }\n  }\n}\n\n/**\n * A Lifetime that lives forever. Used for constants.\n */\nexport class StaticLifetime<T, Owner = never> extends Lifetime<T, T, Owner> {\n  constructor(value: T, owner?: Owner) {\n    super(value, undefined, undefined, owner)\n  }\n\n  // Static lifetime doesn't need a copier to be copiable\n  get dupable() {\n    return true\n  }\n\n  // Copy returns the same instance.\n  dup() {\n    return this\n  }\n\n  // Dispose does nothing.\n  dispose() {}\n}\n\n/**\n * A Lifetime that does not own its `value`. A WeakLifetime never calls its\n * `disposer` function, but can be `dup`ed to produce regular lifetimes that\n * do.\n *\n * Used for function arguments.\n */\nexport class WeakLifetime<T, TCopy = never, Owner = never> extends Lifetime<T, TCopy, Owner> {\n  constructor(\n    value: T,\n    copier?: (value: T | TCopy) => TCopy,\n    disposer?: (value: TCopy) => void,\n    owner?: Owner,\n  ) {\n    // We don't care if the disposer doesn't support freeing T\n    super(value, copier, disposer as (value: T | TCopy) => void, owner)\n  }\n\n  dispose() {\n    this._alive = false\n  }\n}\n\nfunction scopeFinally(scope: Scope, blockError: Error | undefined) {\n  // console.log('scopeFinally', scope, blockError)\n  let disposeError: Error | undefined\n  try {\n    scope.dispose()\n  } catch (error) {\n    disposeError = error as any\n  }\n\n  if (blockError && disposeError) {\n    Object.assign(blockError, {\n      message: `${blockError.message}\\n Then, failed to dispose scope: ${disposeError.message}`,\n      disposeError,\n    })\n    throw blockError\n  }\n\n  if (blockError || disposeError) {\n    throw blockError || disposeError\n  }\n}\n\n/**\n * Scope helps reduce the burden of manually tracking and disposing of\n * Lifetimes. See {@link withScope}. and {@link withScopeAsync}.\n */\nexport class Scope extends UsingDisposable implements Disposable {\n  /**\n   * Run `block` with a new Scope instance that will be disposed after the block returns.\n   * Inside `block`, call `scope.manage` on each lifetime you create to have the lifetime\n   * automatically disposed after the block returns.\n   *\n   * @warning Do not use with async functions. Instead, use {@link withScopeAsync}.\n   */\n  static withScope<R>(block: (scope: Scope) => R): R {\n    const scope = new Scope()\n    let blockError: Error | undefined\n    try {\n      return block(scope)\n    } catch (error) {\n      blockError = error as any\n      throw error\n    } finally {\n      scopeFinally(scope, blockError)\n    }\n  }\n\n  static withScopeMaybeAsync<Return, This, Yielded>(\n    _this: This,\n    block: MaybeAsyncBlock<Return, This, Yielded, [Scope]>,\n  ): Return | Promise<Return> {\n    return maybeAsync(undefined, function* (awaited) {\n      const scope = new Scope()\n      let blockError: Error | undefined\n      try {\n        return yield* awaited.of(block.call(_this, awaited, scope))\n      } catch (error) {\n        blockError = error as any\n        throw error\n      } finally {\n        scopeFinally(scope, blockError)\n      }\n    })\n  }\n\n  /**\n   * Run `block` with a new Scope instance that will be disposed after the\n   * block's returned promise settles. Inside `block`, call `scope.manage` on each\n   * lifetime you create to have the lifetime automatically disposed after the\n   * block returns.\n   */\n  static async withScopeAsync<R>(block: (scope: Scope) => Promise<R>): Promise<R> {\n    const scope = new Scope()\n    let blockError: Error | undefined\n    try {\n      return await block(scope)\n    } catch (error) {\n      blockError = error as any\n      throw error\n    } finally {\n      scopeFinally(scope, blockError)\n    }\n  }\n\n  private _disposables: Lifetime<Set<Disposable>> = new Lifetime(new Set())\n\n  /**\n   * Track `lifetime` so that it is disposed when this scope is disposed.\n   */\n  manage<T extends Disposable>(lifetime: T): T {\n    this._disposables.value.add(lifetime)\n    return lifetime\n  }\n\n  get alive() {\n    return this._disposables.alive\n  }\n\n  dispose() {\n    const lifetimes = Array.from(this._disposables.value.values()).reverse()\n    for (const lifetime of lifetimes) {\n      if (lifetime.alive) {\n        lifetime.dispose()\n      }\n    }\n    this._disposables.dispose()\n  }\n}\n","import { UsingDisposable, type Disposable } from \"./lifetime\"\nimport type { QuickJSHandle } from \"./types\"\nimport type { QuickJSRuntime } from \"./runtime\"\nimport type { QuickJSContext } from \"./context\"\nexport type { PromiseExecutor } from \"./types\"\n\n/**\n * A promise state inside QuickJS, which can be pending, fulfilled, or rejected.\n * You can unwrap a JSPromiseState with {@link QuickJSContext#unwrapResult}.\n */\nexport type JSPromiseState =\n  | JSPromiseStatePending\n  | JSPromiseStateFulfilled\n  | JSPromiseStateRejected\n\n/**\n * Pending promise state.\n * See {@link JSPromiseState}.\n */\nexport interface JSPromiseStatePending {\n  type: \"pending\"\n  /**\n   * The error property here allows unwrapping a JSPromiseState with {@link QuickJSContext#unwrapResult}.\n   * Unwrapping a pending promise will throw a {@link QuickJSPromisePending} error.\n   */\n  get error(): Error\n}\n\n/**\n * Fulfilled promise state.\n * See {@link JSPromiseState}.\n */\nexport interface JSPromiseStateFulfilled {\n  type: \"fulfilled\"\n  value: QuickJSHandle\n  error?: undefined\n  /** Trying to get the promise state of a non-Promise value returns a fulfilled state with the original value, and `notAPromise: true`. */\n  notAPromise?: boolean\n}\n\n/**\n * Rejected promise state.\n * See {@link JSPromiseState}.\n */\nexport interface JSPromiseStateRejected {\n  type: \"rejected\"\n  error: QuickJSHandle\n}\n\n/**\n * QuickJSDeferredPromise wraps a QuickJS promise {@link handle} and allows\n * {@link resolve}ing or {@link reject}ing that promise. Use it to bridge asynchronous\n * code on the host to APIs inside a QuickJSContext.\n *\n * Managing the lifetime of promises is tricky. There are three\n * {@link QuickJSHandle}s inside of each deferred promise object: (1) the promise\n * itself, (2) the `resolve` callback, and (3) the `reject` callback.\n *\n * - If the promise will be fulfilled before the end of it's {@link owner}'s lifetime,\n *   the only cleanup necessary is `deferred.handle.dispose()`, because\n *   calling {@link resolve} or {@link reject} will dispose of both callbacks automatically.\n *\n * - As the return value of a {@link VmFunctionImplementation}, return {@link handle},\n *   and ensure that either {@link resolve} or {@link reject} will be called. No other\n *   clean-up is necessary.\n *\n * - In other cases, call {@link dispose}, which will dispose {@link handle} as well as the\n *   QuickJS handles that back {@link resolve} and {@link reject}. For this object,\n *   {@link dispose} is idempotent.\n */\nexport class QuickJSDeferredPromise extends UsingDisposable implements Disposable {\n  public owner: QuickJSRuntime\n  public context: QuickJSContext\n\n  /**\n   * A handle of the Promise instance inside the QuickJSContext.\n   * You must dispose {@link handle} or the entire QuickJSDeferredPromise once you\n   * are finished with it.\n   */\n  public handle: QuickJSHandle\n\n  /**\n   * A native promise that will resolve once this deferred is settled.\n   */\n  public settled: Promise<void>\n\n  private resolveHandle: QuickJSHandle\n  private rejectHandle: QuickJSHandle\n  private onSettled!: () => void\n\n  /**\n   * Use {@link QuickJSContext#newPromise} to create a new promise instead of calling\n   * this constructor directly.\n   */\n  constructor(args: {\n    context: QuickJSContext\n    promiseHandle: QuickJSHandle\n    resolveHandle: QuickJSHandle\n    rejectHandle: QuickJSHandle\n  }) {\n    super()\n    this.context = args.context\n    this.owner = args.context.runtime\n    this.handle = args.promiseHandle\n    this.settled = new Promise((resolve) => {\n      this.onSettled = resolve\n    })\n    this.resolveHandle = args.resolveHandle\n    this.rejectHandle = args.rejectHandle\n  }\n\n  /**\n   * Resolve {@link handle} with the given value, if any.\n   * Calling this method after calling {@link dispose} is a no-op.\n   *\n   * Note that after resolving a promise, you may need to call\n   * {@link QuickJSRuntime#executePendingJobs} to propagate the result to the promise's\n   * callbacks.\n   */\n  resolve = (value?: QuickJSHandle) => {\n    if (!this.resolveHandle.alive) {\n      return\n    }\n\n    this.context\n      .unwrapResult(\n        this.context.callFunction(\n          this.resolveHandle,\n          this.context.undefined,\n          value || this.context.undefined,\n        ),\n      )\n      .dispose()\n\n    this.disposeResolvers()\n    this.onSettled()\n  }\n\n  /**\n   * Reject {@link handle} with the given value, if any.\n   * Calling this method after calling {@link dispose} is a no-op.\n   *\n   * Note that after rejecting a promise, you may need to call\n   * {@link QuickJSRuntime#executePendingJobs} to propagate the result to the promise's\n   * callbacks.\n   */\n  reject = (value?: QuickJSHandle) => {\n    if (!this.rejectHandle.alive) {\n      return\n    }\n\n    this.context\n      .unwrapResult(\n        this.context.callFunction(\n          this.rejectHandle,\n          this.context.undefined,\n          value || this.context.undefined,\n        ),\n      )\n      .dispose()\n\n    this.disposeResolvers()\n    this.onSettled()\n  }\n\n  get alive() {\n    return this.handle.alive || this.resolveHandle.alive || this.rejectHandle.alive\n  }\n\n  dispose = () => {\n    if (this.handle.alive) {\n      this.handle.dispose()\n    }\n    this.disposeResolvers()\n  }\n\n  private disposeResolvers() {\n    if (this.resolveHandle.alive) {\n      this.resolveHandle.dispose()\n    }\n\n    if (this.rejectHandle.alive) {\n      this.rejectHandle.dispose()\n    }\n  }\n}\n","import type {\n  EitherModule,\n  OwnedHeapCharPointer,\n  JSContextPointerPointer,\n  JSValueConstPointerPointer,\n  JSValuePointerPointer,\n  JSVoidPointer,\n} from \"@jitl/quickjs-ffi-types\"\nimport { Lifetime } from \"./lifetime\"\nimport type { QuickJSHandle } from \"./types\"\n\n/**\n * @private\n */\ntype HeapUint8Array = {\n  pointer: JSVoidPointer\n  numBytes: number\n}\n\n/**\n * @private\n */\nexport class ModuleMemory {\n  constructor(public module: EitherModule) {}\n\n  toPointerArray(handleArray: QuickJSHandle[]): Lifetime<JSValueConstPointerPointer> {\n    const typedArray = new Int32Array(handleArray.map((handle) => handle.value))\n    const numBytes = typedArray.length * typedArray.BYTES_PER_ELEMENT\n    const ptr = this.module._malloc(numBytes) as JSValueConstPointerPointer\n    const heapBytes = new Uint8Array(this.module.HEAPU8.buffer, ptr, numBytes)\n    heapBytes.set(new Uint8Array(typedArray.buffer))\n    return new Lifetime(ptr, undefined, (ptr) => this.module._free(ptr))\n  }\n\n  newMutablePointerArray<T extends JSContextPointerPointer | JSValuePointerPointer>(\n    length: number,\n  ): Lifetime<{ typedArray: Int32Array; ptr: T }> {\n    const zeros = new Int32Array(new Array(length).fill(0))\n    const numBytes = zeros.length * zeros.BYTES_PER_ELEMENT\n    const ptr = this.module._malloc(numBytes) as T\n    const typedArray = new Int32Array(this.module.HEAPU8.buffer, ptr, length)\n    typedArray.set(zeros)\n    return new Lifetime({ typedArray, ptr }, undefined, (value) => this.module._free(value.ptr))\n  }\n\n  newHeapCharPointer(string: string): Lifetime<{ ptr: OwnedHeapCharPointer; strlen: number }> {\n    const strlen = this.module.lengthBytesUTF8(string)\n    const dataBytes = strlen + 1\n    const ptr: OwnedHeapCharPointer = this.module._malloc(dataBytes) as OwnedHeapCharPointer\n    this.module.stringToUTF8(string, ptr, dataBytes)\n    return new Lifetime({ ptr, strlen }, undefined, (value) => this.module._free(value.ptr))\n  }\n\n  newHeapBufferPointer(buffer: Uint8Array): Lifetime<HeapUint8Array> {\n    const numBytes = buffer.byteLength\n    const ptr: JSVoidPointer = this.module._malloc(numBytes) as JSVoidPointer\n    this.module.HEAPU8.set(buffer, ptr)\n    return new Lifetime({ pointer: ptr, numBytes }, undefined, (value) =>\n      this.module._free(value.pointer),\n    )\n  }\n\n  consumeHeapCharPointer(ptr: OwnedHeapCharPointer): string {\n    const str = this.module.UTF8ToString(ptr)\n    this.module._free(ptr)\n    return str\n  }\n}\n","import type { JSContextPointer, JSValueConstPointer, JSValuePointer } from \"@jitl/quickjs-ffi-types\"\nimport { EvalFlags, IntrinsicsFlags } from \"@jitl/quickjs-ffi-types\"\nimport type { QuickJSContext } from \"./context\"\nimport type { SuccessOrFail, VmFunctionImplementation } from \"./vm-interface\"\nimport type { Disposable, Lifetime } from \"./lifetime\"\nimport type { QuickJSAsyncContext } from \"./context-asyncify\"\nimport type { InterruptHandler, QuickJSRuntime } from \"./runtime\"\nimport { QuickJSUnknownIntrinsic } from \"./errors\"\n\n/**\n * A QuickJSHandle to a constant that will never change, and does not need to\n * be disposed.\n */\nexport type StaticJSValue = Lifetime<JSValueConstPointer, JSValueConstPointer, QuickJSRuntime>\n\n/**\n * A QuickJSHandle to a borrowed value that does not need to be disposed.\n *\n * In QuickJS, a JSValueConst is a \"borrowed\" reference that isn't owned by the\n * current scope. That means that the current scope should not `JS_FreeValue`\n * it, or retain a reference to it after the scope exits, because it may be\n * freed by its owner.\n *\n * quickjs-emscripten takes care of disposing JSValueConst references.\n */\nexport type JSValueConst = Lifetime<JSValueConstPointer, JSValuePointer, QuickJSRuntime>\n\n/**\n * A owned QuickJSHandle that should be disposed or returned.\n *\n * The QuickJS interpreter passes Javascript values between functions as\n * `JSValue` structs that references some internal data. Because passing\n * structs cross the Empscripten FFI interfaces is bothersome, we use pointers\n * to these structs instead.\n *\n * A JSValue reference is \"owned\" in its scope. before exiting the scope, it\n * should be freed,  by calling `JS_FreeValue(ctx, js_value)`) or returned from\n * the scope. We extend that contract - a JSValuePointer (`JSValue*`) must also\n * be `free`d.\n *\n * You can do so from Javascript by calling the .dispose() method.\n */\nexport type JSValue = Lifetime<JSValuePointer, JSValuePointer, QuickJSRuntime>\n\n/**\n * Wraps a C pointer to a QuickJS JSValue, which represents a Javascript value inside\n * a QuickJS virtual machine.\n *\n * Values must not be shared between QuickJSContext instances.\n * You must dispose of any handles you create by calling the `.dispose()` method.\n */\nexport type QuickJSHandle = StaticJSValue | JSValue | JSValueConst\n\nexport type JSModuleExport =\n  | {\n      type: \"function\"\n      name: string\n      implementation: (vm: QuickJSContext) => VmFunctionImplementation<QuickJSHandle>\n    }\n  | { type: \"value\"; name: string; value: (vm: QuickJSContext) => QuickJSHandle }\n\nexport interface JSModuleDefinition {\n  name: string\n  exports: JSModuleExport[]\n}\n\nexport type JSModuleLoadSuccess = string\nexport type JSModuleLoadFailure = Error | QuickJSHandle\nexport type JSModuleLoadResult =\n  | JSModuleLoadSuccess\n  | SuccessOrFail<JSModuleLoadSuccess, JSModuleLoadFailure>\n\nexport interface JSModuleLoaderAsync {\n  /** Load module (async) */\n  (\n    moduleName: string,\n    context: QuickJSAsyncContext,\n  ): JSModuleLoadResult | Promise<JSModuleLoadResult>\n}\nexport interface JSModuleLoader {\n  /** Load module (sync) */\n  (moduleName: string, context: QuickJSContext): JSModuleLoadResult\n}\n\nexport type JSModuleNormalizeSuccess = string\nexport type JSModuleNormalizeFailure = Error | QuickJSHandle\nexport type JSModuleNormalizeResult =\n  | JSModuleNormalizeSuccess\n  | SuccessOrFail<JSModuleNormalizeSuccess, JSModuleNormalizeFailure>\n\nexport interface JSModuleNormalizerAsync {\n  (\n    baseModuleName: string,\n    requestedName: string,\n    vm: QuickJSAsyncContext,\n  ): JSModuleNormalizeResult | Promise<JSModuleNormalizeResult>\n}\nexport interface JSModuleNormalizer extends JSModuleNormalizerAsync {\n  (baseModuleName: string, requestedName: string, vm: QuickJSContext): JSModuleNormalizeResult\n}\n\ntype TODO<hint extends string = \"?\", typeHint = unknown> = hint & typeHint & never\n\nconst UnstableSymbol = Symbol(\"Unstable\")\n\nexport type PartiallyImplemented<T> = never &\n  T & {\n    [UnstableSymbol]: \"This feature may unimplemented, broken, throw errors, etc.\"\n  }\n\nexport interface RuntimeOptionsBase {\n  interruptHandler?: InterruptHandler\n  maxStackSizeBytes?: number\n  memoryLimitBytes?: number\n\n  promiseRejectionHandler?: TODO<\"JSHostPromiseRejectionTracker\">\n  runtimeInfo?: TODO<\"JS_SetRuntimeInfo\", string>\n  gcThreshold?: TODO<\"JS_SetGCThreshold\", number>\n  sharedArrayBufferFunctions?: TODO<\n    \"JS_SetJSSharedArrayBufferFunctions\",\n    { sab_alloc: TODO; sab_free: TODO; sab_dup: TODO; sab_opaque: TODO }\n  >\n\n  /**\n   * Extra lifetimes the runtime should dispose of after it is destroyed.\n   * @private\n   */\n  ownedLifetimes?: Disposable[]\n}\n\nexport interface RuntimeOptions extends RuntimeOptionsBase {\n  moduleLoader?: JSModuleLoader\n}\n\nexport interface AsyncRuntimeOptions extends RuntimeOptionsBase {\n  moduleLoader?: JSModuleLoaderAsync | JSModuleLoader\n}\n\n// This guy could be declared as Partial<Record<keyof typeof IntrinsicsFlags, boolean>>,\n// but it leads to bad docs.\n/**\n * Language features that can be enabled or disabled in a QuickJSContext.\n * @see {@link ContextOptions}\n */\nexport type Intrinsics = {\n  BaseObjects?: boolean\n  Date?: boolean\n  Eval?: boolean\n  StringNormalize?: boolean\n  RegExp?: boolean\n  RegExpCompiler?: boolean\n  JSON?: boolean\n  Proxy?: boolean\n  MapSet?: boolean\n  TypedArrays?: boolean\n  Promise?: boolean\n  BigInt?: boolean\n  BigFloat?: boolean\n  BigDecimal?: boolean\n  OperatorOverloading?: boolean\n  BignumExt?: boolean\n}\n\ntype _Assert<T, U extends T> = U\ntype _intrinsicsHasKeysOfIntrinsicFlags = _Assert<keyof Intrinsics, keyof typeof IntrinsicsFlags>\ntype _intrinsicsHasKeysOfIntrinsicFlags2 = _Assert<keyof typeof IntrinsicsFlags, keyof Intrinsics>\n\n/**\n * The default {@link Intrinsics} language features enabled in a QuickJSContext.\n * @see {@link ContextOptions}\n */\nexport const DefaultIntrinsics = Object.freeze({\n  BaseObjects: true,\n  Date: true,\n  Eval: true,\n  StringNormalize: true,\n  RegExp: true,\n  JSON: true,\n  Proxy: true,\n  MapSet: true,\n  TypedArrays: true,\n  Promise: true,\n} as const satisfies Intrinsics)\n\n/**\n * @private\n */\nexport function intrinsicsToFlags(intrinsics: Intrinsics | undefined): IntrinsicsFlags {\n  if (!intrinsics) {\n    return 0 as IntrinsicsFlags\n  }\n\n  let result = 0\n  for (const [maybeIntrinsicName, enabled] of Object.entries(intrinsics)) {\n    if (!(maybeIntrinsicName in IntrinsicsFlags)) {\n      throw new QuickJSUnknownIntrinsic(maybeIntrinsicName)\n    }\n    const intrinsicName = maybeIntrinsicName as keyof typeof IntrinsicsFlags\n\n    if (enabled) {\n      result |= IntrinsicsFlags[intrinsicName]\n    }\n  }\n  return result as IntrinsicsFlags\n}\n\n/**\n * Options for creating a {@link QuickJSContext} or {@link QuickJSAsyncContext}\n * Pass to {@link QuickJSRuntime#newContext}.\n */\nexport interface ContextOptions {\n  /**\n   * What built-in objects and language features to enable?\n   * If unset, the default intrinsics will be used.\n   * To omit all intrinsics, pass an empty array.\n   *\n   * To remove a specific intrinsic, but retain the other defaults,\n   * override it from {@link DefaultIntrinsics}\n   * ```ts\n   * const contextWithoutDateOrEval = runtime.newContext({\n   *   intrinsics: {\n   *     ...DefaultIntrinsics,\n   *     Date: false,\n   *   }\n   * })\n   * ```\n   */\n  intrinsics?: Intrinsics\n\n  /**\n   * Wrap the provided context instead of constructing a new one.\n   * @private\n   */\n  contextPointer?: JSContextPointer\n\n  /**\n   * Extra lifetimes the context should dispose of after it is destroyed.\n   * @private\n   */\n  ownedLifetimes?: Disposable[]\n}\n\nexport interface ContextEvalOptions {\n  /**\n   * Global code (default), or \"module\" code?\n   *\n   * - When type is `\"global\"`, the code is evaluated in the global scope of the QuickJSContext, and the return value is the result of the last expression.\n   * - When type is `\"module\"`, the code is evaluated is a module scope, may use `import`, `export`, and top-level `await`. The return value is the module's exports, or a promise for the module's exports.\n   */\n  type?: \"global\" | \"module\"\n  /** Force \"strict\" mode */\n  strict?: boolean\n  /** Force \"strip\" mode */\n  strip?: boolean\n  /**\n   * compile but do not run. The result is an object with a\n   * JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed\n   * with JS_EvalFunction().\n   */\n  compileOnly?: boolean\n  /** don't include the stack frames before this eval in the Error() backtraces */\n  backtraceBarrier?: boolean\n}\n\n/** Convert {@link ContextEvalOptions} to a bitfield flags */\nexport function evalOptionsToFlags(evalOptions: ContextEvalOptions | number | undefined): number {\n  if (typeof evalOptions === \"number\") {\n    return evalOptions\n  }\n\n  if (evalOptions === undefined) {\n    return 0\n  }\n\n  const { type, strict, strip, compileOnly, backtraceBarrier } = evalOptions\n  let flags = 0\n  if (type === \"global\") flags |= EvalFlags.JS_EVAL_TYPE_GLOBAL\n  if (type === \"module\") flags |= EvalFlags.JS_EVAL_TYPE_MODULE\n  if (strict) flags |= EvalFlags.JS_EVAL_FLAG_STRICT\n  if (strip) flags |= EvalFlags.JS_EVAL_FLAG_STRIP\n  if (compileOnly) flags |= EvalFlags.JS_EVAL_FLAG_COMPILE_ONLY\n  if (backtraceBarrier) flags |= EvalFlags.JS_EVAL_FLAG_BACKTRACE_BARRIER\n  return flags\n}\n\nexport type PromiseExecutor<ResolveT, RejectT> = (\n  resolve: (value: ResolveT | PromiseLike<ResolveT>) => void,\n  reject: (reason: RejectT) => void,\n) => void\n\nexport function concat<T>(...values: Array<T[] | T | undefined>): T[] {\n  let result: T[] = []\n  for (const value of values) {\n    if (value !== undefined) {\n      result = result.concat(value)\n    }\n  }\n  return result\n}\n","import { JSPromiseStateEnum } from \"@jitl/quickjs-ffi-types\"\nimport type {\n  EvalFlags,\n  EitherModule,\n  EvalDetectModule,\n  JSBorrowedCharPointer,\n  JSContextPointer,\n  JSRuntimePointer,\n  JSValueConstPointer,\n  JSValuePointer,\n  JSValuePointerPointer,\n  EitherFFI,\n} from \"@jitl/quickjs-ffi-types\"\nimport { debugLog } from \"./debug\"\nimport type { JSPromiseState } from \"./deferred-promise\"\nimport { QuickJSDeferredPromise } from \"./deferred-promise\"\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { shouldInterruptAfterDeadline } from \"./interrupt-helpers\"\nimport { QuickJSPromisePending, QuickJSUnwrapError } from \"./errors\"\nimport type { Disposable } from \"./lifetime\"\nimport { Lifetime, Scope, StaticLifetime, UsingDisposable, WeakLifetime } from \"./lifetime\"\nimport { ModuleMemory } from \"./memory\"\nimport type { ContextCallbacks, QuickJSModuleCallbacks } from \"./module\"\nimport type {\n  QuickJSRuntime,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ExecutePendingJobsResult,\n} from \"./runtime\"\nimport type { ContextEvalOptions, JSValue, PromiseExecutor, QuickJSHandle } from \"./types\"\nimport { evalOptionsToFlags } from \"./types\"\nimport type {\n  LowLevelJavascriptVm,\n  SuccessOrFail,\n  VmCallResult,\n  VmFunctionImplementation,\n  VmPropertyDescriptor,\n} from \"./vm-interface\"\n\n/**\n * Property key for getting or setting a property on a handle with\n * {@link QuickJSContext#getProp}, {@link QuickJSContext#setProp}, or {@link QuickJSContext#defineProp}.\n */\nexport type QuickJSPropertyKey = number | string | QuickJSHandle\n\n/**\n * @private\n */\nclass ContextMemory extends ModuleMemory implements Disposable {\n  readonly owner: QuickJSRuntime\n  readonly ctx: Lifetime<JSContextPointer>\n  readonly rt: Lifetime<JSRuntimePointer>\n  readonly module: EitherModule\n  readonly ffi: EitherFFI\n  readonly scope = new Scope()\n\n  /** @private */\n  constructor(args: {\n    owner: QuickJSRuntime\n    module: EitherModule\n    ffi: EitherFFI\n    ctx: Lifetime<JSContextPointer>\n    rt: Lifetime<JSRuntimePointer>\n    ownedLifetimes?: Disposable[]\n  }) {\n    super(args.module)\n    args.ownedLifetimes?.forEach((lifetime) => this.scope.manage(lifetime))\n    this.owner = args.owner\n    this.module = args.module\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.ctx = this.scope.manage(args.ctx)\n  }\n\n  get alive() {\n    return this.scope.alive\n  }\n\n  dispose() {\n    return this.scope.dispose()\n  }\n\n  [Symbol.dispose]() {\n    return this.dispose()\n  }\n\n  /**\n   * Track `lifetime` so that it is disposed when this scope is disposed.\n   */\n  manage<T extends Disposable>(lifetime: T): T {\n    return this.scope.manage(lifetime)\n  }\n\n  copyJSValue = (ptr: JSValuePointer | JSValueConstPointer) => {\n    return this.ffi.QTS_DupValuePointer(this.ctx.value, ptr)\n  }\n\n  freeJSValue = (ptr: JSValuePointer) => {\n    this.ffi.QTS_FreeValuePointer(this.ctx.value, ptr)\n  }\n\n  consumeJSCharPointer(ptr: JSBorrowedCharPointer): string {\n    const str = this.module.UTF8ToString(ptr)\n    this.ffi.QTS_FreeCString(this.ctx.value, ptr)\n    return str\n  }\n\n  heapValueHandle(ptr: JSValuePointer): JSValue {\n    return new Lifetime(ptr, this.copyJSValue, this.freeJSValue, this.owner)\n  }\n}\n\n/**\n * QuickJSContext wraps a QuickJS Javascript context (JSContext*) within a\n * runtime. The contexts within the same runtime may exchange objects freely.\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain. The {@link runtime} references the context's runtime.\n *\n * This class's methods return {@link QuickJSHandle}, which wrap C pointers (JSValue*).\n * It's the caller's responsibility to call `.dispose()` on any\n * handles you create to free memory once you're done with the handle.\n *\n * Use {@link QuickJSRuntime#newContext} or {@link QuickJSWASMModule#newContext}\n * to create a new QuickJSContext.\n *\n * Create QuickJS values inside the interpreter with methods like\n * {@link newNumber}, {@link newString}, {@link newArray}, {@link newObject},\n * {@link newFunction}, and {@link newPromise}.\n *\n * Call {@link setProp} or {@link defineProp} to customize objects. Use those methods\n * with {@link global} to expose the values you create to the interior of the\n * interpreter, so they can be used in {@link evalCode}.\n *\n * Use {@link evalCode} or {@link callFunction} to execute Javascript inside the VM. If\n * you're using asynchronous code inside the QuickJSContext, you may need to also\n * call {@link QuickJSRuntime#executePendingJobs}. Executing code inside the runtime returns a\n * result object representing successful execution or an error. You must dispose\n * of any such results to avoid leaking memory inside the VM.\n *\n * Implement memory and CPU constraints at the runtime level, using {@link runtime}.\n * See {@link QuickJSRuntime} for more information.\n *\n */\n// TODO: Manage own callback registration\nexport class QuickJSContext\n  extends UsingDisposable\n  implements LowLevelJavascriptVm<QuickJSHandle>, Disposable\n{\n  /**\n   * The runtime that created this context.\n   */\n  public readonly runtime: QuickJSRuntime\n\n  /** @private */\n  protected readonly ctx: Lifetime<JSContextPointer>\n  /** @private */\n  protected readonly rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected readonly module: EitherModule\n  /** @private */\n  protected readonly ffi: EitherFFI\n  /** @private */\n  protected memory: ContextMemory\n\n  /** @private */\n  protected _undefined: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _null: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _false: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _true: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _global: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _BigInt: QuickJSHandle | undefined = undefined\n\n  /**\n   * Use {@link QuickJSRuntime#newContext} or {@link QuickJSWASMModule#newContext}\n   * to create a new QuickJSContext.\n   */\n  constructor(args: {\n    module: EitherModule\n    ffi: EitherFFI\n    ctx: Lifetime<JSContextPointer>\n    rt: Lifetime<JSRuntimePointer>\n    runtime: QuickJSRuntime\n    ownedLifetimes?: Disposable[]\n    callbacks: QuickJSModuleCallbacks\n  }) {\n    super()\n    this.runtime = args.runtime\n    this.module = args.module\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.ctx = args.ctx\n    this.memory = new ContextMemory({\n      ...args,\n      owner: this.runtime,\n    })\n    args.callbacks.setContextCallbacks(this.ctx.value, this.cToHostCallbacks)\n    this.dump = this.dump.bind(this)\n    this.getString = this.getString.bind(this)\n    this.getNumber = this.getNumber.bind(this)\n    this.resolvePromise = this.resolvePromise.bind(this)\n  }\n\n  // @implement Disposable ----------------------------------------------------\n\n  get alive() {\n    return this.memory.alive\n  }\n\n  /**\n   * Dispose of this VM's underlying resources.\n   *\n   * @throws Calling this method without disposing of all created handles\n   * will result in an error.\n   */\n  dispose() {\n    this.memory.dispose()\n  }\n\n  // Globals ------------------------------------------------------------------\n\n  /**\n   * [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined).\n   */\n  get undefined(): QuickJSHandle {\n    if (this._undefined) {\n      return this._undefined\n    }\n\n    // Undefined is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetUndefined()\n    return (this._undefined = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null).\n   */\n  get null(): QuickJSHandle {\n    if (this._null) {\n      return this._null\n    }\n\n    // Null is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetNull()\n    return (this._null = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`true`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/true).\n   */\n  get true(): QuickJSHandle {\n    if (this._true) {\n      return this._true\n    }\n\n    // True is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetTrue()\n    return (this._true = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`false`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/false).\n   */\n  get false(): QuickJSHandle {\n    if (this._false) {\n      return this._false\n    }\n\n    // False is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetFalse()\n    return (this._false = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).\n   * A handle to the global object inside the interpreter.\n   * You can set properties to create global variables.\n   */\n  get global(): QuickJSHandle {\n    if (this._global) {\n      return this._global\n    }\n\n    // The global is a JSValue, but since it's lifetime is as long as the VM's,\n    // we should manage it.\n    const ptr = this.ffi.QTS_GetGlobalObject(this.ctx.value)\n\n    // Automatically clean up this reference when we dispose\n    this.memory.manage(this.memory.heapValueHandle(ptr))\n\n    // This isn't technically a static lifetime, but since it has the same\n    // lifetime as the VM, it's okay to fake one since when the VM is\n    // disposed, no other functions will accept the value.\n    this._global = new StaticLifetime(ptr, this.runtime)\n    return this._global\n  }\n\n  // New values ---------------------------------------------------------------\n\n  /**\n   * Converts a Javascript number into a QuickJS value.\n   */\n  newNumber(num: number): QuickJSHandle {\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value, num))\n  }\n\n  /**\n   * Create a QuickJS [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) value.\n   */\n  newString(str: string): QuickJSHandle {\n    const ptr = this.memory\n      .newHeapCharPointer(str)\n      .consume((charHandle) => this.ffi.QTS_NewString(this.ctx.value, charHandle.value.ptr))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a QuickJS [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) value.\n   * No two symbols created with this function will be the same value.\n   */\n  newUniqueSymbol(description: string | symbol): QuickJSHandle {\n    const key = (typeof description === \"symbol\" ? description.description : description) ?? \"\"\n    const ptr = this.memory\n      .newHeapCharPointer(key)\n      .consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value.ptr, 0))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Get a symbol from the [global registry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry) for the given key.\n   * All symbols created with the same key will be the same value.\n   */\n  newSymbolFor(key: string | symbol): QuickJSHandle {\n    const description = (typeof key === \"symbol\" ? key.description : key) ?? \"\"\n    const ptr = this.memory\n      .newHeapCharPointer(description)\n      .consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value.ptr, 1))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a QuickJS [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) value.\n   */\n  newBigInt(num: bigint): QuickJSHandle {\n    if (!this._BigInt) {\n      const bigIntHandle = this.getProp(this.global, \"BigInt\")\n      this.memory.manage(bigIntHandle)\n      this._BigInt = new StaticLifetime(bigIntHandle.value as JSValueConstPointer, this.runtime)\n    }\n\n    const bigIntHandle = this._BigInt\n    const asString = String(num)\n    return this.newString(asString).consume((handle) =>\n      this.unwrapResult(this.callFunction(bigIntHandle, this.undefined, handle)),\n    )\n  }\n\n  /**\n   * `{}`.\n   * Create a new QuickJS [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer).\n   *\n   * @param prototype - Like [`Object.create`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create).\n   */\n  newObject(prototype?: QuickJSHandle): QuickJSHandle {\n    if (prototype) {\n      this.runtime.assertOwned(prototype)\n    }\n    const ptr = prototype\n      ? this.ffi.QTS_NewObjectProto(this.ctx.value, prototype.value)\n      : this.ffi.QTS_NewObject(this.ctx.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * `[]`.\n   * Create a new QuickJS [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).\n   */\n  newArray(): QuickJSHandle {\n    const ptr = this.ffi.QTS_NewArray(this.ctx.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   *  Create a new QuickJS [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).\n   */\n  newArrayBuffer(buffer: ArrayBufferLike): QuickJSHandle {\n    const array = new Uint8Array(buffer)\n    const handle = this.memory.newHeapBufferPointer(array)\n    const ptr = this.ffi.QTS_NewArrayBuffer(this.ctx.value, handle.value.pointer, array.length)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a new {@link QuickJSDeferredPromise}. Use `deferred.resolve(handle)` and\n   * `deferred.reject(handle)` to fulfill the promise handle available at `deferred.handle`.\n   * Note that you are responsible for calling `deferred.dispose()` to free the underlying\n   * resources; see the documentation on {@link QuickJSDeferredPromise} for details.\n   */\n  newPromise(): QuickJSDeferredPromise\n  /**\n   * Create a new {@link QuickJSDeferredPromise} that resolves when the\n   * given native Promise<QuickJSHandle> resolves. Rejections will be coerced\n   * to a QuickJS error.\n   *\n   * You can still resolve/reject the created promise \"early\" using its methods.\n   */\n  newPromise(promise: Promise<QuickJSHandle>): QuickJSDeferredPromise\n  /**\n   * Construct a new native Promise<QuickJSHandle>, and then convert it into a\n   * {@link QuickJSDeferredPromise}.\n   *\n   * You can still resolve/reject the created promise \"early\" using its methods.\n   */\n  newPromise(\n    newPromiseFn: PromiseExecutor<QuickJSHandle, Error | QuickJSHandle>,\n  ): QuickJSDeferredPromise\n  newPromise(\n    value?: PromiseExecutor<QuickJSHandle, Error | QuickJSHandle> | Promise<QuickJSHandle>,\n  ): QuickJSDeferredPromise {\n    const deferredPromise = Scope.withScope((scope) => {\n      const mutablePointerArray = scope.manage(\n        this.memory.newMutablePointerArray<JSValuePointerPointer>(2),\n      )\n      const promisePtr = this.ffi.QTS_NewPromiseCapability(\n        this.ctx.value,\n        mutablePointerArray.value.ptr,\n      )\n      const promiseHandle = this.memory.heapValueHandle(promisePtr)\n      const [resolveHandle, rejectHandle] = Array.from(mutablePointerArray.value.typedArray).map(\n        (jsvaluePtr) => this.memory.heapValueHandle(jsvaluePtr as any),\n      )\n      return new QuickJSDeferredPromise({\n        context: this,\n        promiseHandle,\n        resolveHandle,\n        rejectHandle,\n      })\n    })\n\n    if (value && typeof value === \"function\") {\n      value = new Promise(value)\n    }\n\n    if (value) {\n      Promise.resolve(value).then(deferredPromise.resolve, (error) =>\n        error instanceof Lifetime\n          ? deferredPromise.reject(error)\n          : this.newError(error).consume(deferredPromise.reject),\n      )\n    }\n\n    return deferredPromise\n  }\n\n  /**\n   * Convert a Javascript function into a QuickJS function value.\n   * See {@link VmFunctionImplementation} for more details.\n   *\n   * A {@link VmFunctionImplementation} should not free its arguments or its return\n   * value. A VmFunctionImplementation should also not retain any references to\n   * its return value.\n   *\n   * The function argument handles are automatically disposed when the function\n   * returns. If you want to retain a handle beyond the end of the function, you\n   * can call {@link Lifetime#dup} to create a copy of the handle that you own\n   * and must dispose manually. For example, you need to use this API and do some\n   * extra book keeping to implement `setInterval`:\n   *\n   * ```typescript\n   * // This won't work because `callbackHandle` expires when the function returns,\n   * // so when the interval fires, the callback handle is already disposed.\n   * const WRONG_setIntervalHandle = context.newFunction(\"setInterval\", (callbackHandle, delayHandle) => {\n   *   const delayMs = context.getNumber(delayHandle)\n   *   const intervalId = globalThis.setInterval(() => {\n   *     // ERROR: callbackHandle is already disposed here.\n   *     context.callFunction(callbackHandle)\n   *   }, intervalId)\n   *   return context.newNumber(intervalId)\n   * })\n   *\n   * // This works since we dup the callbackHandle.\n   * // We just need to make sure we clean it up manually when the interval is cleared --\n   * // so we need to keep track of those interval IDs, and make sure we clean all\n   * // of them up when we dispose the owning context.\n   *\n   * const setIntervalHandle = context.newFunction(\"setInterval\", (callbackHandle, delayHandle) => {\n   *   // Ensure the guest can't overload us by scheduling too many intervals.\n   *   if (QuickJSInterval.INTERVALS.size > 100) {\n   *     throw new Error(`Too many intervals scheduled already`)\n   *   }\n   *\n   *   const delayMs = context.getNumber(delayHandle)\n   *   const longLivedCallbackHandle = callbackHandle.dup()\n   *   const intervalId = globalThis.setInterval(() => {\n   *     context.callFunction(longLivedCallbackHandle)\n   *   }, intervalId)\n   *   const disposable = new QuickJSInterval(longLivedCallbackHandle, context, intervalId)\n   *   QuickJSInterval.INTERVALS.set(intervalId, disposable)\n   *   return context.newNumber(intervalId)\n   * })\n   *\n   * const clearIntervalHandle = context.newFunction(\"clearInterval\", (intervalIdHandle) => {\n   *   const intervalId = context.getNumber(intervalIdHandle)\n   *   const disposable = QuickJSInterval.INTERVALS.get(intervalId)\n   *   disposable?.dispose()\n   * })\n   *\n   * class QuickJSInterval extends UsingDisposable {\n   *   static INTERVALS = new Map<number, QuickJSInterval>()\n   *\n   *   static disposeContext(context: QuickJSContext) {\n   *     for (const interval of QuickJSInterval.INTERVALS.values()) {\n   *       if (interval.context === context) {\n   *         interval.dispose()\n   *       }\n   *     }\n   *   }\n   *\n   *   constructor(\n   *     public fnHandle: QuickJSHandle,\n   *     public context: QuickJSContext,\n   *     public intervalId: number,\n   *   ) {\n   *     super()\n   *   }\n   *\n   *   dispose() {\n   *     globalThis.clearInterval(this.intervalId)\n   *     this.fnHandle.dispose()\n   *     QuickJSInterval.INTERVALS.delete(this.fnHandle.value)\n   *   }\n   *\n   *   get alive() {\n   *     return this.fnHandle.alive\n   *   }\n   * }\n   * ```\n   *\n   * To implement an async function, create a promise with {@link newPromise}, then\n   * return the deferred promise handle from `deferred.handle` from your\n   * function implementation:\n   *\n   * ```typescript\n   * const deferred = vm.newPromise()\n   * someNativeAsyncFunction().then(deferred.resolve)\n   * return deferred.handle\n   * ```\n   */\n  newFunction(name: string, fn: VmFunctionImplementation<QuickJSHandle>): QuickJSHandle {\n    const fnId = ++this.fnNextId\n    this.setFunction(fnId, fn)\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value, fnId, name))\n  }\n\n  newError(error: { name: string; message: string }): QuickJSHandle\n  newError(message: string): QuickJSHandle\n  newError(): QuickJSHandle\n  newError(error?: string | { name: string; message: string }): QuickJSHandle {\n    const errorHandle = this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value))\n\n    if (error && typeof error === \"object\") {\n      if (error.name !== undefined) {\n        this.newString(error.name).consume((handle) => this.setProp(errorHandle, \"name\", handle))\n      }\n\n      if (error.message !== undefined) {\n        this.newString(error.message).consume((handle) =>\n          this.setProp(errorHandle, \"message\", handle),\n        )\n      }\n    } else if (typeof error === \"string\") {\n      this.newString(error).consume((handle) => this.setProp(errorHandle, \"message\", handle))\n    } else if (error !== undefined) {\n      // This isn't supported in the type signature but maybe it will make life easier.\n      this.newString(String(error)).consume((handle) =>\n        this.setProp(errorHandle, \"message\", handle),\n      )\n    }\n\n    return errorHandle\n  }\n\n  // Read values --------------------------------------------------------------\n\n  /**\n   * `typeof` operator. **Not** [standards compliant](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof).\n   *\n   * @remarks\n   * Does not support BigInt values correctly.\n   */\n  typeof(handle: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    return this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value, handle.value))\n  }\n\n  /**\n   * Converts `handle` into a Javascript number.\n   * @returns `NaN` on error, otherwise a `number`.\n   */\n  getNumber(handle: QuickJSHandle): number {\n    this.runtime.assertOwned(handle)\n    return this.ffi.QTS_GetFloat64(this.ctx.value, handle.value)\n  }\n\n  /**\n   * Converts `handle` to a Javascript string.\n   */\n  getString(handle: QuickJSHandle): string {\n    this.runtime.assertOwned(handle)\n    return this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value, handle.value))\n  }\n\n  /**\n   * Converts `handle` into a Javascript symbol. If the symbol is in the global\n   * registry in the guest, it will be created with Symbol.for on the host.\n   */\n  getSymbol(handle: QuickJSHandle): symbol {\n    this.runtime.assertOwned(handle)\n    const key = this.memory.consumeJSCharPointer(\n      this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value, handle.value),\n    )\n    const isGlobal = this.ffi.QTS_IsGlobalSymbol(this.ctx.value, handle.value)\n    return isGlobal ? Symbol.for(key) : Symbol(key)\n  }\n\n  /**\n   * Converts `handle` to a Javascript bigint.\n   */\n  getBigInt(handle: QuickJSHandle): bigint {\n    this.runtime.assertOwned(handle)\n    const asString = this.getString(handle)\n    return BigInt(asString)\n  }\n\n  /**\n   * Coverts `handle` to a JavaScript ArrayBuffer\n   */\n  getArrayBuffer(handle: QuickJSHandle): Lifetime<Uint8Array> {\n    this.runtime.assertOwned(handle)\n    const len = this.ffi.QTS_GetArrayBufferLength(this.ctx.value, handle.value)\n    const ptr = this.ffi.QTS_GetArrayBuffer(this.ctx.value, handle.value)\n    if (!ptr) {\n      throw new Error(\"Couldn't allocate memory to get ArrayBuffer\")\n    }\n    return new Lifetime(this.module.HEAPU8.subarray(ptr, ptr + len), undefined, () =>\n      this.module._free(ptr),\n    )\n  }\n\n  /**\n   * Get the current state of a QuickJS promise, see {@link JSPromiseState} for the possible states.\n   * This can be used to expect a promise to be fulfilled when combined with {@link unwrapResult}:\n   *\n   * ```typescript\n   * const promiseHandle = context.evalCode(`Promise.resolve(42)`);\n   * const resultHandle = context.unwrapResult(\n   *  context.getPromiseState(promiseHandle)\n   * );\n   * context.getNumber(resultHandle) === 42; // true\n   * resultHandle.dispose();\n   * ```\n   */\n  getPromiseState(handle: QuickJSHandle): JSPromiseState {\n    this.runtime.assertOwned(handle)\n    const state = this.ffi.QTS_PromiseState(this.ctx.value, handle.value)\n    if (state < 0) {\n      // Not a promise, but act like `await` would with non-promise, and just return the value.\n      return { type: \"fulfilled\", value: handle, notAPromise: true }\n    }\n\n    if (state === JSPromiseStateEnum.Pending) {\n      return {\n        type: \"pending\",\n        get error() {\n          return new QuickJSPromisePending(`Cannot unwrap a pending promise`)\n        },\n      }\n    }\n\n    const ptr = this.ffi.QTS_PromiseResult(this.ctx.value, handle.value)\n    const result = this.memory.heapValueHandle(ptr)\n    if (state === JSPromiseStateEnum.Fulfilled) {\n      return { type: \"fulfilled\", value: result }\n    }\n    if (state === JSPromiseStateEnum.Rejected) {\n      return { type: \"rejected\", error: result }\n    }\n    result.dispose()\n    throw new Error(`Unknown JSPromiseStateEnum: ${state}`)\n  }\n\n  /**\n   * `Promise.resolve(value)`.\n   * Convert a handle containing a Promise-like value inside the VM into an\n   * actual promise on the host.\n   *\n   * @remarks\n   * You may need to call {@link runtime}.{@link QuickJSRuntime#executePendingJobs} to ensure that the promise is resolved.\n   *\n   * @param promiseLikeHandle - A handle to a Promise-like value with a `.then(onSuccess, onError)` method.\n   */\n  resolvePromise(promiseLikeHandle: QuickJSHandle): Promise<VmCallResult<QuickJSHandle>> {\n    this.runtime.assertOwned(promiseLikeHandle)\n    const vmResolveResult = Scope.withScope((scope) => {\n      const vmPromise = scope.manage(this.getProp(this.global, \"Promise\"))\n      const vmPromiseResolve = scope.manage(this.getProp(vmPromise, \"resolve\"))\n      return this.callFunction(vmPromiseResolve, vmPromise, promiseLikeHandle)\n    })\n    if (vmResolveResult.error) {\n      return Promise.resolve(vmResolveResult)\n    }\n\n    return new Promise<VmCallResult<QuickJSHandle>>((resolve) => {\n      Scope.withScope((scope) => {\n        const resolveHandle = scope.manage(\n          this.newFunction(\"resolve\", (value) => {\n            resolve({ value: value && value.dup() })\n          }),\n        )\n\n        const rejectHandle = scope.manage(\n          this.newFunction(\"reject\", (error) => {\n            resolve({ error: error && error.dup() })\n          }),\n        )\n\n        const promiseHandle = scope.manage(vmResolveResult.value)\n        const promiseThenHandle = scope.manage(this.getProp(promiseHandle, \"then\"))\n        this.unwrapResult(\n          this.callFunction(promiseThenHandle, promiseHandle, resolveHandle, rejectHandle),\n        ).dispose()\n      })\n    })\n  }\n\n  // Properties ---------------------------------------------------------------\n\n  /**\n   * `handle[key]`.\n   * Get a property from a JSValue.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string (which will be converted automatically).\n   */\n  getProp(handle: QuickJSHandle, key: QuickJSPropertyKey): QuickJSHandle {\n    this.runtime.assertOwned(handle)\n    const ptr = this.borrowPropertyKey(key).consume((quickJSKey) =>\n      this.ffi.QTS_GetProp(this.ctx.value, handle.value, quickJSKey.value),\n    )\n    const result = this.memory.heapValueHandle(ptr)\n\n    return result\n  }\n\n  /**\n   * `handle[key] = value`.\n   * Set a property on a JSValue.\n   *\n   * @remarks\n   * Note that the QuickJS authors recommend using {@link defineProp} to define new\n   * properties.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  setProp(handle: QuickJSHandle, key: QuickJSPropertyKey, value: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    // free newly allocated value if key was a string or number. No-op if string was already\n    // a QuickJS handle.\n    this.borrowPropertyKey(key).consume((quickJSKey) =>\n      this.ffi.QTS_SetProp(this.ctx.value, handle.value, quickJSKey.value, value.value),\n    )\n  }\n\n  /**\n   * [`Object.defineProperty(handle, key, descriptor)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  defineProp(\n    handle: QuickJSHandle,\n    key: QuickJSPropertyKey,\n    descriptor: VmPropertyDescriptor<QuickJSHandle>,\n  ): void {\n    this.runtime.assertOwned(handle)\n    Scope.withScope((scope) => {\n      const quickJSKey = scope.manage(this.borrowPropertyKey(key))\n\n      const value = descriptor.value || this.undefined\n      const configurable = Boolean(descriptor.configurable)\n      const enumerable = Boolean(descriptor.enumerable)\n      const hasValue = Boolean(descriptor.value)\n      const get = descriptor.get\n        ? scope.manage(this.newFunction(descriptor.get.name, descriptor.get))\n        : this.undefined\n      const set = descriptor.set\n        ? scope.manage(this.newFunction(descriptor.set.name, descriptor.set))\n        : this.undefined\n\n      this.ffi.QTS_DefineProp(\n        this.ctx.value,\n        handle.value,\n        quickJSKey.value,\n        value.value,\n        get.value,\n        set.value,\n        configurable,\n        enumerable,\n        hasValue,\n      )\n    })\n  }\n\n  // Evaluation ---------------------------------------------------------------\n\n  /**\n   * [`func.call(thisVal, ...args)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call).\n   * Call a JSValue as a function.\n   *\n   * See {@link unwrapResult}, which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use {@link resolvePromise} to convert it to a native promise and\n   * {@link runtime}.{@link QuickJSRuntime#executePendingJobs} to finish evaluating the promise.\n   *\n   * @returns A result. If the function threw synchronously, `result.error` be a\n   * handle to the exception. Otherwise `result.value` will be a handle to the\n   * value.\n   */\n  callFunction(\n    func: QuickJSHandle,\n    thisVal: QuickJSHandle,\n    ...args: QuickJSHandle[]\n  ): VmCallResult<QuickJSHandle> {\n    this.runtime.assertOwned(func)\n    const resultPtr = this.memory\n      .toPointerArray(args)\n      .consume((argsArrayPtr) =>\n        this.ffi.QTS_Call(\n          this.ctx.value,\n          func.value,\n          thisVal.value,\n          args.length,\n          argsArrayPtr.value,\n        ),\n      )\n\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Like [`eval(code)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Description).\n   *\n   * Evaluates `code`, as though it's in a file named `filename`, with options `options`.\n   *\n   * - When `options.type` is `\"global\"`, the code is evaluated in the global\n   *   scope of the QuickJSContext, and the return value is the result of the last\n   *   expression.\n   * - When `options.type` is `\"module\"`, the code is evaluated is a module scope.\n   *   It may use `import` and `export` if {@link runtime}.{@link QuickJSRuntime#setModuleLoader} was called.\n   *   It may use top-level await if supported by the underlying QuickJS library.\n   *   The return value is the module's exports, or a promise for the module's exports.\n   * - When `options.type` is unset, the code is evaluated as a module if it\n   *   contains an `import` or `export` statement, otherwise it is evaluated in\n   *   the global scope.\n   *\n   * When working with async code, you many need to call {@link runtime}.{@link QuickJSRuntime#executePendingJobs}\n   * to execute callbacks pending after synchronous evaluation returns.\n   *\n   * See {@link unwrapResult}, which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use {@link resolvePromise} to convert it to a native promise and\n   * {@link QuickJSRuntime#executePendingJobs} to finish evaluating the promise.\n   *\n   * *Note*: to protect against infinite loops, provide an interrupt handler to\n   * {@link QuickJSRuntime#setInterruptHandler}. You can use {@link shouldInterruptAfterDeadline} to\n   * create a time-based deadline.\n   *\n   * @returns The last statement's value. If the code threw synchronously,\n   * `result.error` will be a handle to the exception. If execution was\n   * interrupted, the error will have name `InternalError` and message\n   * `interrupted`.\n   */\n  evalCode(\n    code: string,\n    filename: string = \"eval.js\",\n    /**\n     * If no options are passed, a heuristic will be used to detect if `code` is\n     * an ES module.\n     *\n     * See {@link EvalFlags} for number semantics.\n     */\n    options?: number | ContextEvalOptions,\n  ): VmCallResult<QuickJSHandle> {\n    const detectModule = (options === undefined ? 1 : 0) as EvalDetectModule\n    const flags = evalOptionsToFlags(options) as EvalFlags\n    const resultPtr = this.memory\n      .newHeapCharPointer(code)\n      .consume((charHandle) =>\n        this.ffi.QTS_Eval(\n          this.ctx.value,\n          charHandle.value.ptr,\n          charHandle.value.strlen,\n          filename,\n          detectModule,\n          flags,\n        ),\n      )\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Throw an error in the VM, interrupted whatever current execution is in progress when execution resumes.\n   * @experimental\n   */\n  throw(error: Error | QuickJSHandle) {\n    return this.errorToHandle(error).consume((handle) =>\n      this.ffi.QTS_Throw(this.ctx.value, handle.value),\n    )\n  }\n\n  /**\n   * @private\n   */\n  protected borrowPropertyKey(key: QuickJSPropertyKey): QuickJSHandle {\n    if (typeof key === \"number\") {\n      return this.newNumber(key)\n    }\n\n    if (typeof key === \"string\") {\n      return this.newString(key)\n    }\n\n    // key is already a JSValue, but we're borrowing it. Return a static handle\n    // for internal use only.\n    return new StaticLifetime(key.value as JSValueConstPointer, this.runtime)\n  }\n\n  /**\n   * @private\n   */\n  getMemory(rt: JSRuntimePointer): ContextMemory {\n    if (rt === this.rt.value) {\n      return this.memory\n    } else {\n      throw new Error(\"Private API. Cannot get memory from a different runtime\")\n    }\n  }\n\n  // Utilities ----------------------------------------------------------------\n\n  /**\n   * Dump a JSValue to Javascript in a best-effort fashion.\n   * If the value is a promise, dumps the promise's state.\n   * Returns `handle.toString()` if it cannot be serialized to JSON.\n   */\n  dump(handle: QuickJSHandle): any {\n    this.runtime.assertOwned(handle)\n    const type = this.typeof(handle)\n    if (type === \"string\") {\n      return this.getString(handle)\n    } else if (type === \"number\") {\n      return this.getNumber(handle)\n    } else if (type === \"bigint\") {\n      return this.getBigInt(handle)\n    } else if (type === \"undefined\") {\n      return undefined\n    } else if (type === \"symbol\") {\n      return this.getSymbol(handle)\n    }\n\n    // It's confusing if we dump(promise) and just get back {} because promise\n    // has no properties, so dump promise state.\n    const asPromiseState = this.getPromiseState(handle)\n    if (asPromiseState.type === \"fulfilled\" && !asPromiseState.notAPromise) {\n      handle.dispose()\n      return { type: asPromiseState.type, value: asPromiseState.value.consume(this.dump) }\n    } else if (asPromiseState.type === \"pending\") {\n      handle.dispose()\n      return { type: asPromiseState.type }\n    } else if (asPromiseState.type === \"rejected\") {\n      handle.dispose()\n      return { type: asPromiseState.type, error: asPromiseState.error.consume(this.dump) }\n    }\n\n    const str = this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value, handle.value))\n    try {\n      return JSON.parse(str)\n    } catch (err) {\n      return str\n    }\n  }\n\n  /**\n   * Unwrap a SuccessOrFail result such as a {@link VmCallResult} or a\n   * {@link ExecutePendingJobsResult}, where the fail branch contains a handle to a QuickJS error value.\n   * If the result is a success, returns the value.\n   * If the result is an error, converts the error to a native object and throws the error.\n   */\n  unwrapResult<T>(result: SuccessOrFail<T, QuickJSHandle>): T {\n    if (result.error) {\n      const context: QuickJSContext =\n        \"context\" in result.error ? (result.error as { context: QuickJSContext }).context : this\n      const cause = result.error.consume((error) => this.dump(error))\n\n      if (cause && typeof cause === \"object\" && typeof cause.message === \"string\") {\n        const { message, name, stack } = cause\n        const exception = new QuickJSUnwrapError(\"\")\n        const hostStack = exception.stack\n\n        if (typeof name === \"string\") {\n          exception.name = cause.name\n        }\n\n        if (typeof stack === \"string\") {\n          exception.stack = `${name}: ${message}\\n${cause.stack}Host: ${hostStack}`\n        }\n\n        Object.assign(exception, { cause, context, message })\n        throw exception\n      }\n\n      throw new QuickJSUnwrapError(cause, context)\n    }\n\n    return result.value\n  }\n\n  /** @private */\n  protected fnNextId = -32768 // min value of signed 16bit int used by Quickjs\n  /** @private */\n  protected fnMaps = new Map<number, Map<number, VmFunctionImplementation<QuickJSHandle>>>()\n\n  /** @private */\n  protected getFunction(fn_id: number): VmFunctionImplementation<QuickJSHandle> | undefined {\n    const map_id = fn_id >> 8\n    const fnMap = this.fnMaps.get(map_id)\n    if (!fnMap) {\n      return undefined\n    }\n    return fnMap.get(fn_id)\n  }\n\n  /** @private */\n  protected setFunction(fn_id: number, handle: VmFunctionImplementation<QuickJSHandle>) {\n    const map_id = fn_id >> 8\n    let fnMap = this.fnMaps.get(map_id)\n    if (!fnMap) {\n      fnMap = new Map<number, VmFunctionImplementation<QuickJSHandle>>()\n      this.fnMaps.set(map_id, fnMap)\n    }\n    return fnMap.set(fn_id, handle)\n  }\n\n  /**\n   * @hidden\n   */\n  private cToHostCallbacks: ContextCallbacks = {\n    callFunction: (ctx, this_ptr, argc, argv, fn_id) => {\n      if (ctx !== this.ctx.value) {\n        throw new Error(\"QuickJSContext instance received C -> JS call with mismatched ctx\")\n      }\n\n      const fn = this.getFunction(fn_id)\n      if (!fn) {\n        // this \"throw\" is not catch-able from the TS side. could we somehow handle this higher up?\n        throw new Error(`QuickJSContext had no callback with id ${fn_id}`)\n      }\n\n      return Scope.withScopeMaybeAsync(this, function* (awaited, scope) {\n        const thisHandle = scope.manage(\n          new WeakLifetime(\n            this_ptr,\n            this.memory.copyJSValue,\n            this.memory.freeJSValue,\n            this.runtime,\n          ),\n        )\n        const argHandles = new Array<QuickJSHandle>(argc)\n        for (let i = 0; i < argc; i++) {\n          const ptr = this.ffi.QTS_ArgvGetJSValueConstPointer(argv, i)\n          argHandles[i] = scope.manage(\n            new WeakLifetime(ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime),\n          )\n        }\n\n        try {\n          const result = yield* awaited(fn.apply(thisHandle, argHandles))\n          if (result) {\n            if (\"error\" in result && result.error) {\n              debugLog(\"throw error\", result.error)\n              throw result.error\n            }\n            const handle = scope.manage(result instanceof Lifetime ? result : result.value)\n            return this.ffi.QTS_DupValuePointer(this.ctx.value, handle.value)\n          }\n          return 0 as JSValuePointer\n        } catch (error) {\n          return this.errorToHandle(error as Error).consume((errorHandle) =>\n            this.ffi.QTS_Throw(this.ctx.value, errorHandle.value),\n          )\n        }\n      }) as JSValuePointer\n    },\n  }\n\n  private errorToHandle(error: Error | QuickJSHandle): QuickJSHandle {\n    if (error instanceof Lifetime) {\n      return error\n    }\n\n    return this.newError(error)\n  }\n\n  /**\n   * Outputs QuickJS Objects in binary form\n   *\n   * **WARNING**: QuickJS's binary JSON doesn't have a standard so expect it to change between version\n   *\n   * ```ts\n   * // imagine sending data to another via IPC\n   * let dataLifetime = context.newString(\"This is an example\")\n   *  ?.consume(handle => context.encodeBinaryJSON(handle))\n   *  ?.consume(handle => context.getArrayBuffer(handle))\n   * socket.write(dataLifetime?.value)\n   * ```\n   */\n  encodeBinaryJSON(handle: QuickJSHandle): QuickJSHandle {\n    const ptr = this.ffi.QTS_bjson_encode(this.ctx.value, handle.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Outputs Handle of the given QuickJS Object in binary form\n   *\n   * ```ts\n   * // imagine receiving data from another via IPC\n   * socket.on(\"data\", chunk => {\n   *  context.newArrayBuffer(chunk)\n   *    ?.consume(handle => context.decodeBinaryJSON(handle))\n   *    ?.consume(handle => console.log(context.dump(handle)))\n   * })\n   * ```\n   */\n  decodeBinaryJSON(handle: QuickJSHandle): QuickJSHandle {\n    const ptr = this.ffi.QTS_bjson_decode(this.ctx.value, handle.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n}\n","import type {\n  BorrowedHeapCharPointer,\n  JSContextPointer,\n  JSContextPointerPointer,\n  JSRuntimePointer,\n  EitherFFI,\n  EitherModule,\n} from \"@jitl/quickjs-ffi-types\"\nimport { maybeAsyncFn } from \"./asyncify-helpers\"\nimport { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport { QuickJSWrongOwner } from \"./errors\"\nimport type { Disposable } from \"./lifetime\"\nimport { Lifetime, Scope, UsingDisposable } from \"./lifetime\"\nimport { ModuleMemory } from \"./memory\"\nimport type { QuickJSModuleCallbacks, RuntimeCallbacks } from \"./module\"\nimport type { ContextOptions, JSModuleLoader, JSModuleNormalizer, QuickJSHandle } from \"./types\"\nimport { intrinsicsToFlags } from \"./types\"\nimport type { SuccessOrFail } from \"./vm-interface\"\n\n/**\n * Callback called regularly while the VM executes code.\n * Determines if a VM's execution should be interrupted.\n *\n * @returns `true` to interrupt JS execution inside the VM.\n * @returns `false` or `undefined` to continue JS execution inside the VM.\n */\nexport type InterruptHandler = (runtime: QuickJSRuntime) => boolean | undefined\n\n/**\n * Used as an optional for the results of executing pendingJobs.\n * On success, `value` contains the number of async jobs executed\n * by the runtime.\n * @source\n */\nexport type ExecutePendingJobsResult = SuccessOrFail<\n  /** Number of jobs successfully executed. */\n  number,\n  /** The error that occurred. */\n  QuickJSHandle & {\n    /** The context where the error occurred. */\n    context: QuickJSContext\n  }\n>\n\n/**\n * A runtime represents a Javascript runtime corresponding to an object heap.\n * Several runtimes can exist at the same time but they cannot exchange objects.\n * Inside a given runtime, no multi-threading is supported.\n *\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain.\n *\n * Create a runtime via {@link QuickJSWASMModule.newRuntime}.\n *\n * You should create separate runtime instances for untrusted code from\n * different sources for isolation. However, stronger isolation is also\n * available (at the cost of memory usage), by creating separate WebAssembly\n * modules to further isolate untrusted code.\n * See {@link newQuickJSWASMModule}.\n *\n * Implement memory and CPU constraints with {@link setInterruptHandler}\n * (called regularly while the interpreter runs), {@link setMemoryLimit}, and\n * {@link setMaxStackSize}.\n * Use {@link computeMemoryUsage} or {@link dumpMemoryUsage} to guide memory limit\n * tuning.\n *\n * Configure ES module loading with {@link setModuleLoader}.\n */\nexport class QuickJSRuntime extends UsingDisposable implements Disposable {\n  /**\n   * If this runtime was created as as part of a context, points to the context\n   * associated with the runtime.\n   *\n   * If this runtime was created stand-alone, this may or may not contain a context.\n   * A context here may be allocated if one is needed by the runtime, eg for {@link computeMemoryUsage}.\n   */\n  public context: QuickJSContext | undefined\n\n  /** @private */\n  protected module: EitherModule\n  /** @private */\n  protected memory: ModuleMemory\n  /** @private */\n  protected ffi: EitherFFI\n  /** @private */\n  protected rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected callbacks: QuickJSModuleCallbacks\n  /** @private */\n  protected scope = new Scope()\n\n  /** @private */\n  protected contextMap = new Map<JSContextPointer, QuickJSContext>()\n  /** @private */\n  protected moduleLoader: JSModuleLoader | undefined\n  /** @private */\n  protected moduleNormalizer: JSModuleNormalizer | undefined\n\n  /** @private */\n  constructor(args: {\n    module: EitherModule\n    ffi: EitherFFI\n    rt: Lifetime<JSRuntimePointer>\n    callbacks: QuickJSModuleCallbacks\n    ownedLifetimes?: Disposable[]\n  }) {\n    super()\n    args.ownedLifetimes?.forEach((lifetime) => this.scope.manage(lifetime))\n    this.module = args.module\n    this.memory = new ModuleMemory(this.module)\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.callbacks = args.callbacks\n    this.scope.manage(this.rt)\n    this.callbacks.setRuntimeCallbacks(this.rt.value, this.cToHostCallbacks)\n\n    this.executePendingJobs = this.executePendingJobs.bind(this)\n  }\n\n  get alive() {\n    return this.scope.alive\n  }\n\n  dispose() {\n    return this.scope.dispose()\n  }\n\n  /**\n   * Create a new context within this runtime. Contexts have isolated globals,\n   * but you can explicitly share objects between contexts with the same\n   * runtime.\n   *\n   * You should dispose a created context before disposing this runtime.\n   */\n  newContext(options: ContextOptions = {}): QuickJSContext {\n    const intrinsics = intrinsicsToFlags(options.intrinsics)\n    const ctx = new Lifetime(\n      options.contextPointer || this.ffi.QTS_NewContext(this.rt.value, intrinsics),\n      undefined,\n      (ctx_ptr) => {\n        this.contextMap.delete(ctx_ptr)\n        this.callbacks.deleteContext(ctx_ptr)\n        this.ffi.QTS_FreeContext(ctx_ptr)\n      },\n    )\n\n    const context = new QuickJSContext({\n      module: this.module,\n      ctx,\n      ffi: this.ffi,\n      rt: this.rt,\n      ownedLifetimes: options.ownedLifetimes,\n      runtime: this,\n      callbacks: this.callbacks,\n    })\n    this.contextMap.set(ctx.value, context)\n\n    return context\n  }\n\n  /**\n   * Set the loader for EcmaScript modules requested by any context in this\n   * runtime.\n   *\n   * The loader can be removed with {@link removeModuleLoader}.\n   */\n  setModuleLoader(moduleLoader: JSModuleLoader, moduleNormalizer?: JSModuleNormalizer): void {\n    this.moduleLoader = moduleLoader\n    this.moduleNormalizer = moduleNormalizer\n    this.ffi.QTS_RuntimeEnableModuleLoader(this.rt.value, this.moduleNormalizer ? 1 : 0)\n  }\n\n  /**\n   * Remove the the loader set by {@link setModuleLoader}. This disables module loading.\n   */\n  removeModuleLoader(): void {\n    this.moduleLoader = undefined\n    this.ffi.QTS_RuntimeDisableModuleLoader(this.rt.value)\n  }\n\n  // Runtime management -------------------------------------------------------\n\n  /**\n   * In QuickJS, promises and async functions create pendingJobs. These do not execute\n   * immediately and need to be run by calling {@link executePendingJobs}.\n   *\n   * @return true if there is at least one pendingJob queued up.\n   */\n  hasPendingJob(): boolean {\n    return Boolean(this.ffi.QTS_IsJobPending(this.rt.value))\n  }\n\n  private interruptHandler: InterruptHandler | undefined\n\n  /**\n   * Set a callback which is regularly called by the QuickJS engine when it is\n   * executing code. This callback can be used to implement an execution\n   * timeout.\n   *\n   * The interrupt handler can be removed with {@link removeInterruptHandler}.\n   */\n  setInterruptHandler(cb: InterruptHandler) {\n    const prevInterruptHandler = this.interruptHandler\n    this.interruptHandler = cb\n    if (!prevInterruptHandler) {\n      this.ffi.QTS_RuntimeEnableInterruptHandler(this.rt.value)\n    }\n  }\n\n  /**\n   * Remove the interrupt handler, if any.\n   * See {@link setInterruptHandler}.\n   */\n  removeInterruptHandler() {\n    if (this.interruptHandler) {\n      this.ffi.QTS_RuntimeDisableInterruptHandler(this.rt.value)\n      this.interruptHandler = undefined\n    }\n  }\n\n  /**\n   * Execute pendingJobs on the runtime until `maxJobsToExecute` jobs are\n   * executed (default all pendingJobs), the queue is exhausted, or the runtime\n   * encounters an exception.\n   *\n   * In QuickJS, promises and async functions *inside the runtime* create\n   * pendingJobs. These do not execute immediately and need to triggered to run.\n   *\n   * @param maxJobsToExecute - When negative, run all pending jobs. Otherwise execute\n   * at most `maxJobsToExecute` before returning.\n   *\n   * @return On success, the number of executed jobs. On error, the exception\n   * that stopped execution, and the context it occurred in. Note that\n   * executePendingJobs will not normally return errors thrown inside async\n   * functions or rejected promises. Those errors are available by calling\n   * {@link QuickJSContext#resolvePromise} on the promise handle returned by the async function.\n   */\n  executePendingJobs(maxJobsToExecute: number | void = -1): ExecutePendingJobsResult {\n    const ctxPtrOut = this.memory.newMutablePointerArray<JSContextPointerPointer>(1)\n    const valuePtr = this.ffi.QTS_ExecutePendingJob(\n      this.rt.value,\n      maxJobsToExecute ?? -1,\n      ctxPtrOut.value.ptr,\n    )\n\n    const ctxPtr = ctxPtrOut.value.typedArray[0] as JSContextPointer\n    ctxPtrOut.dispose()\n    if (ctxPtr === 0) {\n      // No jobs executed.\n      this.ffi.QTS_FreeValuePointerRuntime(this.rt.value, valuePtr)\n      return { value: 0 }\n    }\n\n    const context =\n      this.contextMap.get(ctxPtr) ??\n      this.newContext({\n        contextPointer: ctxPtr,\n      })\n\n    const resultValue = context.getMemory(this.rt.value).heapValueHandle(valuePtr)\n    const typeOfRet = context.typeof(resultValue)\n    if (typeOfRet === \"number\") {\n      const executedJobs = context.getNumber(resultValue)\n      resultValue.dispose()\n      return { value: executedJobs }\n    } else {\n      const error = Object.assign(resultValue, { context })\n      return {\n        error,\n      }\n    }\n  }\n\n  /**\n   * Set the max memory this runtime can allocate.\n   * To remove the limit, set to `-1`.\n   */\n  setMemoryLimit(limitBytes: number) {\n    if (limitBytes < 0 && limitBytes !== -1) {\n      throw new Error(\"Cannot set memory limit to negative number. To unset, pass -1\")\n    }\n\n    this.ffi.QTS_RuntimeSetMemoryLimit(this.rt.value, limitBytes)\n  }\n\n  /**\n   * Compute memory usage for this runtime. Returns the result as a handle to a\n   * JSValue object. Use {@link QuickJSContext#dump} to convert to a native object.\n   * Calling this method will allocate more memory inside the runtime. The information\n   * is accurate as of just before the call to `computeMemoryUsage`.\n   * For a human-digestible representation, see {@link dumpMemoryUsage}.\n   */\n  computeMemoryUsage(): QuickJSHandle {\n    const serviceContextMemory = this.getSystemContext().getMemory(this.rt.value)\n    return serviceContextMemory.heapValueHandle(\n      this.ffi.QTS_RuntimeComputeMemoryUsage(this.rt.value, serviceContextMemory.ctx.value),\n    )\n  }\n\n  /**\n   * @returns a human-readable description of memory usage in this runtime.\n   * For programmatic access to this information, see {@link computeMemoryUsage}.\n   */\n  dumpMemoryUsage(): string {\n    return this.memory.consumeHeapCharPointer(this.ffi.QTS_RuntimeDumpMemoryUsage(this.rt.value))\n  }\n\n  /**\n   * Set the max stack size for this runtime, in bytes.\n   * To remove the limit, set to `0`.\n   */\n  setMaxStackSize(stackSize: number) {\n    if (stackSize < 0) {\n      throw new Error(\"Cannot set memory limit to negative number. To unset, pass 0.\")\n    }\n\n    this.ffi.QTS_RuntimeSetMaxStackSize(this.rt.value, stackSize)\n  }\n\n  /**\n   * Assert that `handle` is owned by this runtime.\n   * @throws QuickJSWrongOwner if owned by a different runtime.\n   */\n  assertOwned(handle: QuickJSHandle) {\n    if (handle.owner && handle.owner.rt !== this.rt) {\n      throw new QuickJSWrongOwner(\n        `Handle is not owned by this runtime: ${handle.owner.rt.value} != ${this.rt.value}`,\n      )\n    }\n  }\n\n  private getSystemContext() {\n    if (!this.context) {\n      // We own this context and should dispose of it.\n      this.context = this.scope.manage(this.newContext())\n    }\n    return this.context\n  }\n\n  private cToHostCallbacks: RuntimeCallbacks = {\n    shouldInterrupt: (rt) => {\n      if (rt !== this.rt.value) {\n        throw new Error(\"QuickJSContext instance received C -> JS interrupt with mismatched rt\")\n      }\n\n      const fn = this.interruptHandler\n      if (!fn) {\n        throw new Error(\"QuickJSContext had no interrupt handler\")\n      }\n\n      return fn(this) ? 1 : 0\n    },\n\n    loadModuleSource: maybeAsyncFn(this, function* (awaited, rt, ctx, moduleName) {\n      const moduleLoader = this.moduleLoader\n      if (!moduleLoader) {\n        throw new Error(\"Runtime has no module loader\")\n      }\n\n      if (rt !== this.rt.value) {\n        throw new Error(\"Runtime pointer mismatch\")\n      }\n\n      const context =\n        this.contextMap.get(ctx) ??\n        this.newContext({\n          contextPointer: ctx,\n        })\n\n      try {\n        const result = yield* awaited(moduleLoader(moduleName, context))\n\n        if (typeof result === \"object\" && \"error\" in result && result.error) {\n          debugLog(\"cToHostLoadModule: loader returned error\", result.error)\n          throw result.error\n        }\n\n        const moduleSource =\n          typeof result === \"string\" ? result : \"value\" in result ? result.value : result\n\n        return this.memory.newHeapCharPointer(moduleSource).value.ptr\n      } catch (error) {\n        debugLog(\"cToHostLoadModule: caught error\", error)\n        context.throw(error as any)\n        return 0 as BorrowedHeapCharPointer\n      }\n    }),\n\n    normalizeModule: maybeAsyncFn(\n      this,\n      function* (awaited, rt, ctx, baseModuleName, moduleNameRequest) {\n        const moduleNormalizer = this.moduleNormalizer\n        if (!moduleNormalizer) {\n          throw new Error(\"Runtime has no module normalizer\")\n        }\n\n        if (rt !== this.rt.value) {\n          throw new Error(\"Runtime pointer mismatch\")\n        }\n\n        const context: QuickJSContext =\n          this.contextMap.get(ctx) ??\n          this.newContext({\n            /* TODO: Does this happen? Are we responsible for disposing? I don't think so */\n            contextPointer: ctx,\n          })\n\n        try {\n          const result = yield* awaited(\n            moduleNormalizer(baseModuleName, moduleNameRequest, context),\n          )\n\n          if (typeof result === \"object\" && \"error\" in result && result.error) {\n            debugLog(\"cToHostNormalizeModule: normalizer returned error\", result.error)\n            throw result.error\n          }\n\n          const name = typeof result === \"string\" ? result : result.value\n          return context.getMemory(this.rt.value).newHeapCharPointer(name).value.ptr\n        } catch (error) {\n          debugLog(\"normalizeModule: caught error\", error)\n          context.throw(error as any)\n          return 0 as BorrowedHeapCharPointer\n        }\n      },\n    ),\n  }\n}\n","import type {\n  Asyncify,\n  AsyncifySleepResult,\n  EitherModule,\n  EmscriptenModuleCallbacks,\n  BorrowedHeapCharPointer,\n  JSContextPointer,\n  JSRuntimePointer,\n  JSValuePointer,\n  EitherFFI,\n} from \"@jitl/quickjs-ffi-types\"\nimport type { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport { QuickJSAsyncifyError, QuickJSAsyncifySuspended } from \"./errors\"\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { CustomizeVariantOptions } from \"./from-variant\"\nimport { Lifetime, Scope } from \"./lifetime\"\nimport type { InterruptHandler } from \"./runtime\"\nimport { QuickJSRuntime } from \"./runtime\"\nimport type { ContextOptions, JSModuleLoader, RuntimeOptions, RuntimeOptionsBase } from \"./types\"\nimport { concat } from \"./types\"\n\ntype EmscriptenCallback<BaseArgs extends any[], Result> = (\n  ...args: [Asyncify | undefined, ...BaseArgs]\n) => Result | AsyncifySleepResult<Result>\ntype MaybeAsyncEmscriptenCallback<T extends EmscriptenCallback<any, any>> =\n  T extends EmscriptenCallback<infer Args, infer Result>\n    ? (...args: Args) => Result | Promise<Result>\n    : never\ntype MaybeAsyncEmscriptenCallbacks = {\n  [K in keyof EmscriptenModuleCallbacks]: MaybeAsyncEmscriptenCallback<EmscriptenModuleCallbacks[K]>\n}\n\n/**\n * @private\n */\nexport interface ContextCallbacks {\n  callFunction: MaybeAsyncEmscriptenCallbacks[\"callFunction\"]\n}\n\n/**\n * @private\n */\nexport interface RuntimeCallbacks {\n  shouldInterrupt: MaybeAsyncEmscriptenCallbacks[\"shouldInterrupt\"]\n  loadModuleSource: MaybeAsyncEmscriptenCallbacks[\"loadModuleSource\"]\n  normalizeModule: MaybeAsyncEmscriptenCallbacks[\"normalizeModule\"]\n}\n\nclass QuickJSEmscriptenModuleCallbacks implements EmscriptenModuleCallbacks {\n  public callFunction: EmscriptenModuleCallbacks[\"callFunction\"]\n  public shouldInterrupt: EmscriptenModuleCallbacks[\"shouldInterrupt\"]\n  public loadModuleSource: EmscriptenModuleCallbacks[\"loadModuleSource\"]\n  public normalizeModule: EmscriptenModuleCallbacks[\"normalizeModule\"]\n  constructor(args: EmscriptenModuleCallbacks) {\n    this.callFunction = args.callFunction\n    this.shouldInterrupt = args.shouldInterrupt\n    this.loadModuleSource = args.loadModuleSource\n    this.normalizeModule = args.normalizeModule\n  }\n}\n\n/**\n * Options for {@link QuickJSWASMModule#evalCode}.\n */\nexport interface ModuleEvalOptions {\n  /**\n   * Interrupt evaluation if `shouldInterrupt` returns `true`.\n   * See {@link shouldInterruptAfterDeadline}.\n   */\n  shouldInterrupt?: InterruptHandler\n\n  /**\n   * Memory limit, in bytes, of WebAssembly heap memory used by the QuickJS VM.\n   */\n  memoryLimitBytes?: number\n\n  /**\n   * Stack size limit for this vm, in bytes\n   * To remove the limit, set to `0`.\n   */\n  maxStackSizeBytes?: number\n\n  /**\n   * Module loader for any `import` statements or expressions.\n   */\n  moduleLoader?: JSModuleLoader\n}\n\n/**\n * We use static functions per module to dispatch runtime or context calls from\n * C to the host.  This class manages the indirection from a specific runtime or\n * context pointer to the appropriate callback handler.\n *\n * @private\n */\nexport class QuickJSModuleCallbacks {\n  private module: EitherModule\n  private contextCallbacks = new Map<JSContextPointer, ContextCallbacks>()\n  private runtimeCallbacks = new Map<JSRuntimePointer, RuntimeCallbacks>()\n\n  constructor(module: EitherModule) {\n    this.module = module\n    this.module.callbacks = this.cToHostCallbacks\n  }\n\n  setRuntimeCallbacks(rt: JSRuntimePointer, callbacks: RuntimeCallbacks) {\n    this.runtimeCallbacks.set(rt, callbacks)\n  }\n\n  deleteRuntime(rt: JSRuntimePointer) {\n    this.runtimeCallbacks.delete(rt)\n  }\n\n  setContextCallbacks(ctx: JSContextPointer, callbacks: ContextCallbacks) {\n    this.contextCallbacks.set(ctx, callbacks)\n  }\n\n  deleteContext(ctx: JSContextPointer) {\n    this.contextCallbacks.delete(ctx)\n  }\n\n  private suspendedCount = 0\n  private suspended: QuickJSAsyncifySuspended | undefined\n\n  private handleAsyncify<T>(\n    asyncify: Asyncify | undefined,\n    fn: () => T | Promise<T>,\n  ): T | AsyncifySleepResult<T> {\n    if (asyncify) {\n      // We must always call asyncify.handleSync around our function.\n      // This allows asyncify to resume suspended execution on the second call.\n      // Asyncify internally can detect sync behavior, and avoid suspending.\n      return asyncify.handleSleep((done) => {\n        try {\n          const result = fn()\n          if (!(result instanceof Promise)) {\n            debugLog(\"asyncify.handleSleep: not suspending:\", result)\n            done(result)\n            return\n          }\n\n          // Is promise, we intend to suspend.\n          if (this.suspended) {\n            throw new QuickJSAsyncifyError(\n              `Already suspended at: ${this.suspended.stack}\\nAttempted to suspend at:`,\n            )\n          } else {\n            this.suspended = new QuickJSAsyncifySuspended(`(${this.suspendedCount++})`)\n            debugLog(\"asyncify.handleSleep: suspending:\", this.suspended)\n          }\n\n          result.then(\n            (resolvedResult) => {\n              this.suspended = undefined\n              debugLog(\"asyncify.handleSleep: resolved:\", resolvedResult)\n              done(resolvedResult)\n            },\n            (error) => {\n              debugLog(\"asyncify.handleSleep: rejected:\", error)\n              console.error(\"QuickJS: cannot handle error in suspended function\", error)\n              this.suspended = undefined\n            },\n          )\n        } catch (error) {\n          debugLog(\"asyncify.handleSleep: error:\", error)\n          this.suspended = undefined\n          throw error\n        }\n      })\n    }\n\n    // No asyncify - we should never return a promise.\n    const value = fn()\n    if (value instanceof Promise) {\n      throw new Error(\"Promise return value not supported in non-asyncify context.\")\n    }\n    return value\n  }\n\n  private cToHostCallbacks = new QuickJSEmscriptenModuleCallbacks({\n    callFunction: (asyncify, ctx, this_ptr, argc, argv, fn_id) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const vm = this.contextCallbacks.get(ctx)\n          if (!vm) {\n            throw new Error(`QuickJSContext(ctx = ${ctx}) not found for C function call \"${fn_id}\"`)\n          }\n          return vm.callFunction(ctx, this_ptr, argc, argv, fn_id)\n        } catch (error) {\n          console.error(\"[C to host error: returning null]\", error)\n          return 0 as JSValuePointer\n        }\n      }),\n\n    shouldInterrupt: (asyncify, rt) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const vm = this.runtimeCallbacks.get(rt)\n          if (!vm) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C interrupt`)\n          }\n          return vm.shouldInterrupt(rt)\n        } catch (error) {\n          console.error(\"[C to host interrupt: returning error]\", error)\n          return 1\n        }\n      }),\n\n    loadModuleSource: (asyncify, rt, ctx, moduleName) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const runtimeCallbacks = this.runtimeCallbacks.get(rt)\n          if (!runtimeCallbacks) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`)\n          }\n\n          const loadModule = runtimeCallbacks.loadModuleSource\n          if (!loadModule) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`)\n          }\n          return loadModule(rt, ctx, moduleName)\n        } catch (error) {\n          console.error(\"[C to host module loader error: returning null]\", error)\n          return 0 as BorrowedHeapCharPointer\n        }\n      }),\n\n    normalizeModule: (asyncify, rt, ctx, moduleBaseName, moduleName) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const runtimeCallbacks = this.runtimeCallbacks.get(rt)\n          if (!runtimeCallbacks) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`)\n          }\n\n          const normalizeModule = runtimeCallbacks.normalizeModule\n          if (!normalizeModule) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`)\n          }\n          return normalizeModule(rt, ctx, moduleBaseName, moduleName)\n        } catch (error) {\n          console.error(\"[C to host module loader error: returning null]\", error)\n          return 0 as BorrowedHeapCharPointer\n        }\n      }),\n  })\n}\n\n/**\n * Process RuntimeOptions and apply them to a QuickJSRuntime.\n * @private\n */\nexport function applyBaseRuntimeOptions(\n  runtime: QuickJSRuntime,\n  options: RuntimeOptionsBase,\n): void {\n  if (options.interruptHandler) {\n    runtime.setInterruptHandler(options.interruptHandler)\n  }\n\n  if (options.maxStackSizeBytes !== undefined) {\n    runtime.setMaxStackSize(options.maxStackSizeBytes)\n  }\n\n  if (options.memoryLimitBytes !== undefined) {\n    runtime.setMemoryLimit(options.memoryLimitBytes)\n  }\n}\n\n/**\n * Process ModuleEvalOptions and apply them to a QuickJSRuntime.\n * @private\n */\nexport function applyModuleEvalRuntimeOptions<T extends QuickJSRuntime>(\n  runtime: T,\n  options: ModuleEvalOptions,\n) {\n  if (options.moduleLoader) {\n    runtime.setModuleLoader(options.moduleLoader)\n  }\n\n  if (options.shouldInterrupt) {\n    runtime.setInterruptHandler(options.shouldInterrupt)\n  }\n\n  if (options.memoryLimitBytes !== undefined) {\n    runtime.setMemoryLimit(options.memoryLimitBytes)\n  }\n\n  if (options.maxStackSizeBytes !== undefined) {\n    runtime.setMaxStackSize(options.maxStackSizeBytes)\n  }\n}\n\n/**\n * This class presents a Javascript interface to QuickJS, a Javascript interpreter\n * that supports EcmaScript 2020 (ES2020).\n *\n * It wraps a single WebAssembly module containing the QuickJS library and\n * associated helper C code. WebAssembly modules are completely isolated from\n * each other by the host's WebAssembly runtime. Separate WebAssembly modules\n * have the most isolation guarantees possible with this library.\n *\n * The simplest way to start running code is {@link evalCode}. This shortcut\n * method will evaluate Javascript safely and return the result as a native\n * Javascript value.\n *\n * For more control over the execution environment, or to interact with values\n * inside QuickJS, create a context with {@link newContext} or a runtime with\n * {@link newRuntime}.\n */\nexport class QuickJSWASMModule {\n  /** @private */\n  protected ffi: EitherFFI\n  /** @private */\n  protected callbacks: QuickJSModuleCallbacks\n  /** @private */\n  protected module: EitherModule\n\n  /** @private */\n  constructor(module: EitherModule, ffi: EitherFFI) {\n    this.module = module\n    this.ffi = ffi\n    this.callbacks = new QuickJSModuleCallbacks(module)\n  }\n\n  /**\n   * Create a runtime.\n   * Use the runtime to set limits on CPU and memory usage and configure module\n   * loading for one or more {@link QuickJSContext}s inside the runtime.\n   */\n  newRuntime(options: RuntimeOptions = {}): QuickJSRuntime {\n    const rt = new Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr) => {\n      this.callbacks.deleteRuntime(rt_ptr)\n      this.ffi.QTS_FreeRuntime(rt_ptr)\n    })\n\n    const runtime = new QuickJSRuntime({\n      module: this.module,\n      callbacks: this.callbacks,\n      ffi: this.ffi,\n      rt,\n    })\n\n    applyBaseRuntimeOptions(runtime, options)\n\n    if (options.moduleLoader) {\n      runtime.setModuleLoader(options.moduleLoader)\n    }\n\n    return runtime\n  }\n\n  /**\n   * A simplified API to create a new {@link QuickJSRuntime} and a\n   * {@link QuickJSContext} inside that runtime at the same time. The runtime will\n   * be disposed when the context is disposed.\n   */\n  newContext(options: ContextOptions = {}): QuickJSContext {\n    const runtime = this.newRuntime()\n    const context = runtime.newContext({\n      ...options,\n      ownedLifetimes: concat(runtime, options.ownedLifetimes),\n    })\n    runtime.context = context\n    return context\n  }\n\n  /**\n   * One-off evaluate code without needing to create a {@link QuickJSRuntime} or\n   * {@link QuickJSContext} explicitly.\n   *\n   * To protect against infinite loops, use the `shouldInterrupt` option. The\n   * {@link shouldInterruptAfterDeadline} function will create a time-based deadline.\n   *\n   * If you need more control over how the code executes, create a\n   * {@link QuickJSRuntime} (with {@link newRuntime}) or a {@link QuickJSContext} (with\n   * {@link newContext} or {@link QuickJSRuntime#newContext}), and use its\n   * {@link QuickJSContext#evalCode} method.\n   *\n   * Asynchronous callbacks may not run during the first call to `evalCode`. If\n   * you need to work with async code inside QuickJS, create a runtime and use\n   * {@link QuickJSRuntime#executePendingJobs}.\n   *\n   * @returns The result is coerced to a native Javascript value using JSON\n   * serialization, so properties and values unsupported by JSON will be dropped.\n   *\n   * @throws If `code` throws during evaluation, the exception will be\n   * converted into a native Javascript value and thrown.\n   *\n   * @throws if `options.shouldInterrupt` interrupted execution, will throw a Error\n   * with name `\"InternalError\"` and  message `\"interrupted\"`.\n   */\n  evalCode(code: string, options: ModuleEvalOptions = {}): unknown {\n    return Scope.withScope((scope) => {\n      const vm = scope.manage(this.newContext())\n\n      applyModuleEvalRuntimeOptions(vm.runtime, options)\n      const result = vm.evalCode(code, \"eval.js\")\n\n      if (options.memoryLimitBytes !== undefined) {\n        // Remove memory limit so we can dump the result without exceeding it.\n        vm.runtime.setMemoryLimit(-1)\n      }\n\n      if (result.error) {\n        const error = vm.dump(scope.manage(result.error))\n        throw error\n      }\n\n      const value = vm.dump(scope.manage(result.value))\n      return value\n    })\n  }\n\n  /**\n   * Retrieve the WebAssembly memory used by this QuickJS module.\n   * Use this access very carefully - you are responsible for safe interaction with the memory.\n   *\n   * To supply a custom, pre-initialized memory to QuickJS, create a new variant\n   * and provide the {@link CustomizeVariantOptions#wasmMemory} option.\n   *\n   * @experimental\n   */\n  getWasmMemory(): WebAssembly.Memory {\n    const extensions = this.module.quickjsEmscriptenInit?.(() => {})\n    const memory = extensions?.getWasmMemory?.()\n    if (!memory) {\n      throw new Error(`Variant does not support getting WebAssembly.Memory`)\n    }\n    return memory\n  }\n\n  /**\n   * Get a low-level interface to the QuickJS functions in this WebAssembly\n   * module.\n   * @experimental\n   * @unstable No warranty is provided with this API. It could change at any time.\n   * @private\n   */\n  getFFI(): EitherFFI {\n    return this.ffi\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"343\":\"5cf2d9b9\",\"662\":\"6bba74cd\",\"667\":\"c727fe28\",\"730\":\"12a20934\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/sitrusj/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t341: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkmy_app\"] = self[\"webpackChunkmy_app\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","import type {\n  QuickJSSyncVariant,\n  QuickJSAsyncVariant,\n  QuickJSVariant,\n  EmscriptenModuleLoaderOptions,\n  SourceMapData,\n  QuickJSEmscriptenExtensions,\n} from \"@jitl/quickjs-ffi-types\"\nimport type { QuickJSWASMModule } from \"./module.js\"\nimport type { QuickJSAsyncWASMModule } from \"./module-asyncify.js\"\nimport { QuickJSEmscriptenModuleError } from \"./errors.js\"\nimport { debugLog } from \"./debug.js\"\n\n// Otherwise we have build errors?\nexport { QuickJSSyncVariant, QuickJSAsyncVariant, QuickJSVariant }\n\nexport type PromisedDefault<T> =\n  | T\n  | Promise<T>\n  | Promise<{ default: T }>\n  | Promise<{ default: { default: T } }>\n\n/**\n * Create a new, completely isolated WebAssembly module containing the QuickJS library.\n * See the documentation on {@link QuickJSWASMModule}.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n *\n * @example\n * ```ts\n * const quickjs = new newQuickJSWASMModuleFromVariant(\n *   import('@jitl/quickjs-browser-release-sync-wasm')\n * )\n * ```\n */\nexport async function newQuickJSWASMModuleFromVariant(\n  /**\n   * A {@link QuickJSSyncVariant} to construct the WebAssembly module.\n   */\n  variantOrPromise: PromisedDefault<QuickJSSyncVariant>,\n): Promise<QuickJSWASMModule> {\n  const variant = smartUnwrap(await variantOrPromise)\n  const [wasmModuleLoader, QuickJSFFI, { QuickJSWASMModule }] = await Promise.all([\n    variant.importModuleLoader().then(smartUnwrap),\n    variant.importFFI(),\n    import(\"./module.js\").then(smartUnwrap),\n  ])\n  const wasmModule = await wasmModuleLoader()\n  wasmModule.type = \"sync\"\n  const ffi = new QuickJSFFI(wasmModule)\n  return new QuickJSWASMModule(wasmModule, ffi)\n}\n\n/**\n * Create a new, completely isolated WebAssembly module containing a version of the QuickJS library\n * compiled with Emscripten's [ASYNCIFY](https://emscripten.org/docs/porting/asyncify.html) transform.\n *\n * This version of the library offers features that enable synchronous code\n * inside the VM to interact with asynchronous code in the host environment.\n * See the documentation on {@link QuickJSAsyncWASMModule}, {@link QuickJSAsyncRuntime},\n * and {@link QuickJSAsyncContext}.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n *\n * @example\n * ```ts\n * const quickjs = new newQuickJSAsyncWASMModuleFromVariant(\n *   import('@jitl/quickjs-browser-debug-asyncify-wasm')\n * )\n * ```\n */\nexport async function newQuickJSAsyncWASMModuleFromVariant(\n  /**\n   * A {@link QuickJSAsyncVariant} to construct the WebAssembly module.\n   */\n  variantOrPromise: PromisedDefault<QuickJSAsyncVariant>,\n): Promise<QuickJSAsyncWASMModule> {\n  const variant = smartUnwrap(await variantOrPromise)\n  const [wasmModuleLoader, QuickJSAsyncFFI, { QuickJSAsyncWASMModule }] = await Promise.all([\n    variant.importModuleLoader().then(smartUnwrap),\n    variant.importFFI(),\n    import(\"./module-asyncify.js\").then(smartUnwrap),\n  ])\n  const wasmModule = await wasmModuleLoader()\n  wasmModule.type = \"async\"\n  const ffi = new QuickJSAsyncFFI(wasmModule)\n  return new QuickJSAsyncWASMModule(wasmModule, ffi)\n}\n\n/**\n * Helper intended to memoize the creation of a WebAssembly module.\n * ```typescript\n * const getDebugModule = memoizePromiseFactory(() => newQuickJSWASMModule(DEBUG_SYNC))\n * ```\n */\nexport function memoizePromiseFactory<T>(fn: () => Promise<T>): () => Promise<T> {\n  let promise: Promise<T> | undefined\n  return () => {\n    return (promise ??= fn())\n  }\n}\n\nfunction smartUnwrap<T extends object>(val: T | { default: T } | { default: { default: T } }): T {\n  if (val && `default` in val && val.default) {\n    if (val.default && `default` in val.default && val.default.default) {\n      return val.default.default\n    }\n    return val.default as T\n  }\n  return val as T\n}\n\nexport type OrLoader<T> = T | (() => Promise<T>)\n\nexport interface CustomizeVariantOptions {\n  /** If given, Emscripten will try to load the WebAssembly module data from this location (path or URI) as appropriate for the current platform. */\n  wasmLocation?: string\n  /** If given, Emscripten will compile the WebAssembly.Module from these bytes. */\n  wasmBinary?: OrLoader<ArrayBuffer>\n  /** If given, Emscripten will instantiate the WebAssembly.Instance from this existing WebAssembly.Module */\n  wasmModule?: OrLoader<WebAssembly.Module>\n  /** If given, use the Memory when instantiating the WebAssembly.Instance. */\n  wasmMemory?: OrLoader<WebAssembly.Memory>\n  /** If given, Emscripten will try to load the source map for the WebAssembly module from this location (path or URI) as appropriate for the current platform. */\n  wasmSourceMapLocation?: string\n  /** If given, we will provide the source map to Emscripten directly. This may only be respected if wasmModule is also provided. */\n  wasmSourceMapData?: OrLoader<string | SourceMapData>\n  /**\n   * If set, this method will be called when the runtime needs to load a file,\n   * such as a .wasm WebAssembly file, .mem memory init file, or a file\n   * generated by the file packager.\n   *\n   * The function receives two parameters:\n   *\n   * - `fileName`, the relative path to the file as configured in build\n   * process, eg `\"emscripten-module.wasm\"`.\n   * - `prefix` (path to the main JavaScript file’s directory). This may be `''`\n   * (empty string) in some cases if the Emscripten Javascript code can't locate\n   * itself. Try logging it in your environment.\n   *\n   * It should return the actual URI or path to the requested file.\n   *\n   * This lets you host file packages on a different location than the directory\n   * of the JavaScript file (which is the default expectation), for example if\n   * you want to host them on a CDN.\n   */\n  locateFile?: EmscriptenModuleLoaderOptions[\"locateFile\"]\n  /** The enumerable properties of this object will be passed verbatim, although they may be overwritten if you pass other options. */\n  emscriptenModule?: EmscriptenModuleLoaderOptions\n  /** Debug logger */\n  log?: typeof console.log\n}\n\n/**\n * Create a new variant by overriding how Emscripten obtains the WebAssembly module.\n * This may be necessary in Cloudflare Workers, which can't compile WebAssembly modules from binary data.\n */\nexport function newVariant<T extends QuickJSVariant>(\n  baseVariant: T,\n  options: CustomizeVariantOptions,\n): T {\n  const variant: T = {\n    ...baseVariant,\n    async importModuleLoader() {\n      const moduleLoader = smartUnwrap(await baseVariant.importModuleLoader())\n      return async function newModuleLoader() {\n        const moduleLoaderArg: EmscriptenModuleLoaderOptions = options.emscriptenModule\n          ? { ...options.emscriptenModule }\n          : {}\n        const log =\n          options.log ?? ((...args: unknown[]) => debugLog(\"newVariant moduleLoader:\", ...args))\n        const tapValue = <T>(message: unknown[], val: T) => {\n          log(...message, val)\n          return val\n        }\n\n        const force = <T>(val: OrLoader<T> | undefined): T | undefined | Promise<T> => {\n          if (typeof val === \"function\") {\n            return (val as () => Promise<T>)()\n          }\n          return val\n        }\n\n        if (options.wasmLocation || options.wasmSourceMapLocation || options.locateFile) {\n          moduleLoaderArg.locateFile = (fileName: string, relativeTo: string) => {\n            const args = { fileName, relativeTo }\n            if (fileName.endsWith(\".wasm\") && options.wasmLocation !== undefined) {\n              return tapValue(\n                [\"locateFile .wasm: provide wasmLocation\", args],\n                options.wasmLocation,\n              )\n            }\n\n            if (fileName.endsWith(\".map\")) {\n              if (options.wasmSourceMapLocation !== undefined) {\n                return tapValue(\n                  [\"locateFile .map: provide wasmSourceMapLocation\", args],\n                  options.wasmSourceMapLocation,\n                )\n              }\n\n              if (options.wasmLocation && !options.locateFile) {\n                return tapValue(\n                  [\"locateFile .map: infer from wasmLocation\", args],\n                  options.wasmLocation + \".map\",\n                )\n              }\n            }\n\n            if (options.locateFile) {\n              return tapValue(\n                [\"locateFile: use provided fn\", args],\n                options.locateFile(fileName, relativeTo),\n              )\n            }\n\n            return tapValue([\"locateFile: unhandled, passthrough\", args], fileName)\n          }\n        }\n\n        if (options.wasmBinary) {\n          moduleLoaderArg.wasmBinary = await force(options.wasmBinary)\n        }\n\n        if (options.wasmMemory) {\n          moduleLoaderArg.wasmMemory = await force(options.wasmMemory)\n        }\n\n        const optionsWasmModule = options.wasmModule\n        let modulePromise: Promise<WebAssembly.Module | undefined> | undefined\n        if (optionsWasmModule) {\n          moduleLoaderArg.instantiateWasm = async (imports, onSuccess) => {\n            modulePromise ??= Promise.resolve(force(optionsWasmModule))\n            const wasmModule = await modulePromise\n            if (!wasmModule) {\n              // This should never happen\n              throw new QuickJSEmscriptenModuleError(\n                `options.wasmModule returned ${String(wasmModule)}`,\n              )\n            }\n            const instance = await WebAssembly.instantiate(wasmModule, imports)\n            onSuccess(instance)\n            return instance.exports\n          }\n        }\n\n        moduleLoaderArg.monitorRunDependencies = (left: number) => {\n          log(\"monitorRunDependencies:\", left)\n        }\n\n        // This will be replaced with the actual function by --pre-js\n        // Having the mock around makes our code simpler gives us handy logging\n        // if we need to understand any issues\n        moduleLoaderArg.quickjsEmscriptenInit = () => newMockExtensions(log)\n\n        const resultPromise = moduleLoader(moduleLoaderArg)\n        const extensions = moduleLoaderArg.quickjsEmscriptenInit?.(log)\n        if (\n          optionsWasmModule &&\n          extensions?.receiveWasmOffsetConverter &&\n          !extensions.existingWasmOffsetConverter\n        ) {\n          // Unlikely to be available, we'll usually end up mocking this.\n          // Still if the user has both, we'll take it.\n          const wasmBinary = (await force(options.wasmBinary)) ?? new ArrayBuffer(0)\n\n          modulePromise ??= Promise.resolve(force(optionsWasmModule))\n          const wasmModule = await modulePromise\n          if (!wasmModule) {\n            // This should never happen\n            throw new QuickJSEmscriptenModuleError(\n              `options.wasmModule returned ${String(wasmModule)}`,\n            )\n          }\n          extensions.receiveWasmOffsetConverter(wasmBinary, wasmModule)\n        }\n\n        if (extensions?.receiveSourceMapJSON) {\n          const loadedSourceMapData = await force(options.wasmSourceMapData)\n          if (typeof loadedSourceMapData === \"string\") {\n            extensions.receiveSourceMapJSON(JSON.parse(loadedSourceMapData))\n          } else if (loadedSourceMapData) {\n            extensions.receiveSourceMapJSON(loadedSourceMapData)\n          } else {\n            extensions.receiveSourceMapJSON({ version: 3, names: [], sources: [], mappings: \"\" })\n          }\n        }\n\n        return resultPromise\n      }\n    },\n  }\n  return variant\n}\n\nfunction newMockExtensions(log: typeof console.log): QuickJSEmscriptenExtensions {\n  const mockMessage = `mock called, emscripten module may not be initialized yet`\n  return {\n    mock: true,\n    removeRunDependency(name: string) {\n      log(`${mockMessage}: removeRunDependency called:`, name)\n    },\n    receiveSourceMapJSON(data: unknown) {\n      log(`${mockMessage}: receiveSourceMapJSON called:`, data)\n    },\n    WasmOffsetConverter: undefined,\n    receiveWasmOffsetConverter(bytes: ArrayBuffer, mod: WebAssembly.Module) {\n      log(`${mockMessage}: receiveWasmOffsetConverter called:`, bytes, mod)\n    },\n  }\n}\n","import type { QuickJSContext } from \"./context\"\nimport type { ModuleEvalOptions, QuickJSWASMModule } from \"./module\"\nimport type { QuickJSRuntime } from \"./runtime\"\nimport type { ContextOptions, RuntimeOptions } from \"./types\"\nimport { QuickJSMemoryLeakDetected } from \"./errors\"\nimport { Lifetime } from \"./lifetime\"\n\n/**\n * A test wrapper of {@link QuickJSWASMModule} that keeps a reference to each\n * context or runtime created.\n *\n * Call {@link disposeAll} to reset these sets and calls `dispose` on any left alive\n * (which may throw an error).\n *\n * Call {@link assertNoMemoryAllocated} at the end of a test, when you expect that you've\n * freed all the memory you've ever allocated.\n */\nexport class TestQuickJSWASMModule implements Pick<QuickJSWASMModule, keyof QuickJSWASMModule> {\n  contexts = new Set<QuickJSContext>()\n  runtimes = new Set<QuickJSRuntime>()\n  constructor(private parent: QuickJSWASMModule) {}\n\n  newRuntime(options?: RuntimeOptions): QuickJSRuntime {\n    const runtime = this.parent.newRuntime({\n      ...options,\n      ownedLifetimes: [\n        new Lifetime(undefined, undefined, () => this.runtimes.delete(runtime)),\n        ...(options?.ownedLifetimes ?? []),\n      ],\n    })\n    this.runtimes.add(runtime)\n    return runtime\n  }\n\n  newContext(options?: ContextOptions): QuickJSContext {\n    const context = this.parent.newContext({\n      ...options,\n      ownedLifetimes: [\n        new Lifetime(undefined, undefined, () => this.contexts.delete(context)),\n        ...(options?.ownedLifetimes ?? []),\n      ],\n    })\n    this.contexts.add(context)\n    return context\n  }\n\n  evalCode(code: string, options?: ModuleEvalOptions): unknown {\n    return this.parent.evalCode(code, options)\n  }\n\n  disposeAll() {\n    const allDisposables = [...this.contexts, ...this.runtimes]\n    this.runtimes.clear()\n    this.contexts.clear()\n    allDisposables.forEach((d) => {\n      if (d.alive) {\n        d.dispose()\n      }\n    })\n  }\n\n  assertNoMemoryAllocated() {\n    const leaksDetected = this.getFFI().QTS_RecoverableLeakCheck()\n    if (leaksDetected) {\n      // Note: this is currently only available when building from source\n      // with debug builds.\n      throw new QuickJSMemoryLeakDetected(\"Leak sanitizer detected un-freed memory\")\n    }\n\n    if (this.contexts.size > 0) {\n      throw new QuickJSMemoryLeakDetected(`${this.contexts.size} contexts leaked`)\n    }\n\n    if (this.runtimes.size > 0) {\n      throw new QuickJSMemoryLeakDetected(`${this.runtimes.size} runtimes leaked`)\n    }\n  }\n\n  getWasmMemory(): WebAssembly.Memory {\n    return this.parent.getWasmMemory()\n  }\n\n  /** @private */\n  getFFI() {\n    return this.parent.getFFI()\n  }\n}\n","import type { QuickJSAsyncVariant } from \"@jitl/quickjs-ffi-types\"\n\n/**\n * ### @jitl/quickjs-wasmfile-release-asyncify\n *\n * [Docs](https://github.com/justjake/quickjs-emscripten/blob/main/doc/@jitl/quickjs-wasmfile-release-asyncify/README.md) |\n * Variant with separate .WASM file. Supports browser ESM, NodeJS ESM, and NodeJS CommonJS.\n *\n * | Variable            |    Setting                     |    Description    |\n * | --                  | --                             | --                |\n * | library             | quickjs             | The original [bellard/quickjs](https://github.com/bellard/quickjs) library. Version [2024-02-14+36911f0d](https://github.com/bellard/quickjs/commit/36911f0d3ab1a4c190a4d5cbe7c2db225a455389) vendored to quickjs-emscripten on 2024-06-15. |\n * | releaseMode         | release         | Optimized for performance; use when building/deploying your application. |\n * | syncMode            | asyncify            | Build run through the ASYNCIFY WebAssembly transform. This imposes substantial size (2x the size of sync) and speed penalties (40% the speed of sync). In return, allows synchronous calls from the QuickJS WASM runtime to async functions on the host. The extra magic makes this variant slower than sync variants. Note that both variants support regular async functions. Only adopt ASYNCIFY if you need to! The [QuickJSAsyncRuntime](https://github.com/justjake/quickjs-emscripten/blob/main/doc/quickjs-emscripten/classes/QuickJSAsyncRuntime.md) and [QuickJSAsyncContext](https://github.com/justjake/quickjs-emscripten/blob/main/doc/quickjs-emscripten/classes/QuickJSAsyncContext.md) classes expose the ASYNCIFY-specific APIs. |\n * | emscriptenInclusion | wasm | Has a separate .wasm file. May offer better caching in your browser, and reduces the size of your JS bundle. If you have issues, try a 'singlefile' variant. |\n * | exports             | require import browser workerd                  | Has these package.json export conditions |\n *\n */\nconst variant: QuickJSAsyncVariant = {\n  type: \"async\",\n  importFFI: () => import(\"./ffi.js\").then((mod) => mod.QuickJSAsyncFFI),\n  importModuleLoader: () =>\n    import(\"@jitl/quickjs-wasmfile-release-asyncify/emscripten-module\").then((mod) => mod.default),\n} as const\n\nexport default variant\n","import type {\n  QuickJSSyncVariant,\n  QuickJSAsyncVariant,\n  QuickJSWASMModule,\n  QuickJSAsyncWASMModule,\n  PromisedDefault,\n} from \"quickjs-emscripten-core\"\nimport {\n  newQuickJSWASMModuleFromVariant,\n  newQuickJSAsyncWASMModuleFromVariant,\n} from \"quickjs-emscripten-core\"\nimport DEBUG_SYNC from \"@jitl/quickjs-wasmfile-debug-sync\"\nimport RELEASE_SYNC from \"@jitl/quickjs-wasmfile-release-sync\"\nimport DEBUG_ASYNC from \"@jitl/quickjs-wasmfile-debug-asyncify\"\nimport RELEASE_ASYNC from \"@jitl/quickjs-wasmfile-release-asyncify\"\n\n/**\n * Create a new, completely isolated WebAssembly module containing the QuickJS library.\n * See the documentation on {@link QuickJSWASMModule}.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nexport async function newQuickJSWASMModule(\n  /**\n   * Optionally, pass a {@link QuickJSSyncVariant} to construct a different WebAssembly module.\n   */\n  variantOrPromise: PromisedDefault<QuickJSSyncVariant> = RELEASE_SYNC,\n): Promise<QuickJSWASMModule> {\n  return newQuickJSWASMModuleFromVariant(variantOrPromise)\n}\n\n/**\n * Create a new, completely isolated WebAssembly module containing a version of the QuickJS library\n * compiled with Emscripten's [ASYNCIFY](https://emscripten.org/docs/porting/asyncify.html) transform.\n *\n * This version of the library offers features that enable synchronous code\n * inside the VM to interact with asynchronous code in the host environment.\n * See the documentation on {@link QuickJSAsyncWASMModule}, {@link QuickJSAsyncRuntime},\n * and {@link QuickJSAsyncContext}.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nexport async function newQuickJSAsyncWASMModule(\n  /**\n   * Optionally, pass a {@link QuickJSAsyncVariant} to construct a different WebAssembly module.\n   */\n  variantOrPromise: PromisedDefault<QuickJSAsyncVariant> = RELEASE_ASYNC,\n): Promise<QuickJSAsyncWASMModule> {\n  return newQuickJSAsyncWASMModuleFromVariant(variantOrPromise)\n}\n\nexport { DEBUG_SYNC, RELEASE_SYNC, DEBUG_ASYNC, RELEASE_ASYNC }\n","import { shouldInterruptAfterDeadline, newQuickJSAsyncWASMModule, UsingDisposable } from \"quickjs-emscripten\"\n\nlet moduleCache = {};\nlet output = \"\";\nlet sensorReadings = [0, 0, 0, 0];\nlet velocity = 0;\nlet configuredAdc = {\n    4: 0,\n    5: 1,\n    6: 2,\n    7: 3\n}\n\n// Cleanup for setInterval\nclass QuickJSInterval extends UsingDisposable {\n  static INTERVALS = new Map()\n\n  static disposeContext(context: QuickJSContext) {\n    for (const interval of QuickJSInterval.INTERVALS.values()) {\n      if (interval.context === context) {\n        interval.dispose()\n      }\n    }\n  }\n\n  constructor(\n    fnHandle,\n    context,\n    intervalId,\n  ) {\n    super()\n  }\n\n  dispose() {\n    clearInterval(this.intervalId)\n    this.fnHandle.dispose()\n    QuickJSInterval.INTERVALS.delete(this.fnHandle.value)\n  }\n\n  get alive() {\n    return this.fnHandle.alive\n  }\n}\n\nlet eventListeners = {\n    \"sensorReadings\": (event) => {\n        sensorReadings = event.data.payload;\n        //console.log(\"sensorReadings:\", sensorReadings)\n        //postMessage({action: \"idk\"})\n    }\n}\n\nonmessage = (event) => {\n    //console.log(e.data);\n    const { action, payload } = event.data;\n    if (action === 'evalCode') {\n        runCode(payload.modules, payload.code);\n    } else if( eventListeners[action] ){\n        eventListeners[action](event);\n    };\n}\n\nasync function initializeVM(vm) {\n    vm.runtime.setModuleLoader((moduleName) => {\n        if (moduleCache[moduleName]) {\n            return moduleCache[moduleName];\n        } else {\n            throw new Error(`Module ${moduleName} not found in cache`);\n        }\n    });\n\n    addFunction(vm, \"__enabledraw\", (on) => {\n        postMessage({ action: \"setDraw\", payload: vm.getNumber(on) !== 0 });\n    });\n\n    setupTimeouts(vm);\n    setupOutput(vm);\n\n    const robot = vm.newObject();\n\n    setUpMotors(vm, robot);\n    setUpSensors(vm, robot);\n\n    setupServo(vm, robot);\n    setupPins(vm, robot);\n    vm.setProp(vm.global, \"robutek\", robot);\n}\n\nfunction addFunction(vm, name, func, parent = vm.global) {\n    const functionHandle = vm.newFunction(name, func);\n    vm.setProp(parent, name, functionHandle);\n    functionHandle.dispose();\n}\n\nfunction setupTimeouts(vm) {\n    const setIntervalHandle = vm.newFunction(\"setInterval\", (callbackHandle, delayHandle) => {\n        // Ensure the guest can't overload us by scheduling too many intervals.\n        if (QuickJSInterval.INTERVALS.size > 100) {\n            throw new Error(`Too many intervals scheduled already`)\n        }\n\n        const delayMs = vm.getNumber(delayHandle)\n        const longLivedCallbackHandle = callbackHandle.dup()\n        const intervalId = setInterval(() => {\n            //console.log(\"called\");\n            vm.callFunction(longLivedCallbackHandle, vm.undefined)\n        }, delayMs)\n        const disposable = new QuickJSInterval(longLivedCallbackHandle, vm, intervalId)\n        QuickJSInterval.INTERVALS.set(intervalId, disposable)\n        return vm.newNumber(intervalId)\n    })\n    vm.setProp(vm.global, \"setInterval\", setIntervalHandle);\n    setIntervalHandle.dispose();\n\n    const setTimeoutHandle = vm.newFunction(\"setTimeout\", (callbackHandle, delayHandle) => {\n        // Ensure the guest can't overload us by scheduling too many intervals.\n        if (QuickJSInterval.INTERVALS.size > 100) {\n            throw new Error(`Too many intervals scheduled already`)\n        }\n\n        const delayMs = vm.getNumber(delayHandle)\n        const longLivedCallbackHandle = callbackHandle.dup()\n        const intervalId = setTimeout(() => {\n            //console.log(\"called\");\n            vm.callFunction(longLivedCallbackHandle, vm.undefined)\n        }, delayMs)\n        const disposable = new QuickJSInterval(longLivedCallbackHandle, vm, intervalId)\n        QuickJSInterval.INTERVALS.set(intervalId, disposable)\n        return vm.newNumber(intervalId)\n    })\n    vm.setProp(vm.global, \"setTimeout\", setTimeoutHandle);\n    setTimeoutHandle.dispose();\n\n    const clearIntervalHandle = vm.newFunction(\"clearInterval\", (intervalIdHandle) => {\n        const intervalId = vm.getNumber(intervalIdHandle)\n        const disposable = QuickJSInterval.INTERVALS.get(intervalId)\n        clearInterval(intervalId);\n        disposable?.dispose()\n    })\n    vm.setProp(vm.global, \"clearInterval\", clearIntervalHandle);\n    clearIntervalHandle.dispose();\n\n    const clearTimeoutHandle = vm.newFunction(\"clearTimeout\", (intervalIdHandle) => {\n        const intervalId = vm.getNumber(intervalIdHandle)\n        const disposable = QuickJSInterval.INTERVALS.get(intervalId)\n        clearTimeout(intervalId)\n        disposable?.dispose()\n    })\n    vm.setProp(vm.global, \"clearTimeout\", clearTimeoutHandle);\n    clearTimeoutHandle.dispose();\n\n    const sleepHandle = vm.newFunction(\"sleep\", (ms) => {\n        const promise = vm.newPromise()\n        setTimeout(() => {\n            promise.resolve();\n        }, vm.getNumber(ms))\n        promise.settled.then(vm.runtime.executePendingJobs)\n        return promise.handle\n    })\n    vm.setProp(vm.global, \"sleep\", sleepHandle);\n    sleepHandle.dispose();\n}\n\nfunction setupOutput(vm) {\n    const logHandle = vm.newFunction(\"log\", (...args) => {\n        const nativeArgs = args.map(vm.dump)\n        output = \"\"\n        nativeArgs.forEach((arg) => output += \" \" + arg);\n        postMessage({ action: \"print\", payload: output + '\\n' });\n    })\n    // Partially implement `console` object\n    const consoleHandle = vm.newObject()\n    vm.setProp(consoleHandle, \"log\", logHandle)\n    vm.setProp(vm.global, \"console\", consoleHandle)\n    consoleHandle.dispose()\n    logHandle.dispose()\n}\n\nfunction setUpMotors(vm, robot) {\n    addFunction(vm, \"setSpeed\", (speed) => {\n        velocity = vm.getNumber(speed) / 60;\n    }, robot);\n\n    addFunction(vm, \"move\", (c = 0, d = vm.newObject()) => {\n        let curve = vm.getNumber(c);\n        let lRate = 1;\n        let rRate = 1;\n\n        if( curve < 0 ){\n            lRate = 1 + curve;\n        } else {\n            rRate = 1 - curve;\n        }\n\n        const distance = vm.getNumber(vm.getProp(d, \"distance\"))\n        const time = vm.getNumber(vm.getProp(d, \"time\"))\n\n        const duration = distance ? { distance: distance } : { time: time };\n\n        const promise = vm.newPromise();\n        postMessage({ action: \"move\", payload: //{ velocity: 10 } });\n                      { velocity: [lRate * velocity, rRate * velocity],\n                        duration: duration\n                      }\n                    });\n        eventListeners[\"stop\"] = (event) => {\n            promise.resolve();\n        }\n        promise.settled.then(vm.runtime.executePendingJobs);\n        return promise.handle;\n    }, robot);\n\n    addFunction(vm, \"rotate\", (angle = vm.newNumber(0)) => {\n        const promise = vm.newPromise();\n        postMessage({ action: \"rotate\", payload: { angle: vm.getNumber(angle), velocity: velocity } });\n        eventListeners[\"stop\"] = (event) => {\n            promise.resolve();\n        }\n        promise.settled.then(vm.runtime.executePendingJobs);\n        return promise.handle;\n    }, robot);\n\n    addFunction(vm, \"stop\", () => {\n        postMessage({ action: \"setVelocity\", payload: [0, 0] });\n    }, robot);\n}\n\nfunction setUpSensors(vm, robot) {\n    const adcHandle = vm.newObject();\n    vm.setProp(vm.global, \"adc\", adcHandle);\n    addFunction(vm, \"read\", (pin) => {\n        //console.log(\"pin:\", sensorReadings[vm.getNumber(pin)])\n        const idx = vm.getNumber(pin);\n        if(configuredAdc[idx] !== undefined){\n            return vm.newNumber(sensorReadings[configuredAdc[idx]]);\n        }\n        postMessage({ action: \"print\", payload: \"Error: invalid reading\" });\n        return NaN;\n    }, adcHandle);\n\n    addFunction(vm, \"configure\", (pin) => {\n        configuredAdc[vm.getNumber(pin)] = vm.getNumber(pin) - 4;\n    }, adcHandle);\n    adcHandle.dispose();\n\n    addFunction(vm, \"switchSensors\", (value) => {\n        const promise = vm.newPromise();\n        postMessage({ action: \"switchSensors\", payload: vm.getNumber(value) });\n        eventListeners[\"switchedSensors\"] = (event) => {\n            promise.resolve();\n        }\n        promise.settled.then(vm.runtime.executePendingJobs);\n        return promise.handle;\n    }, robot);\n\n    const modExports = vm.unwrapResult(vm.evalCode(`\nexport const readSensor = async (sensor) => {\n    switch (sensor) {\n        case 'W_FR':\n            await switchSensors(0);\n            return adc.read(robutek.Pins.Sens1);\n        case 'W_FL':\n            await switchSensors(0);\n            return adc.read(robutek.Pins.Sens2);\n        case 'W_BL':\n            await switchSensors(0);\n            return adc.read(robutek.Pins.Sens3);\n        case 'W_BR':\n            await switchSensors(0);\n            return adc.read(robutek.Pins.Sens4);\n        case 'L_FR':\n            await switchSensors(1);\n            return adc.read(robutek.Pins.Sens1);\n        case 'L_FL':\n            await switchSensors(1);\n            return adc.read(robutek.Pins.Sens2);\n        case 'L_BL':\n            await switchSensors(1);\n            return adc.read(robutek.Pins.Sens3);\n        case 'L_BR':\n            await switchSensors(1);\n            return adc.read(robutek.Pins.Sens4);\n        default:\n            return NaN;\n    }\n}`));\n    vm.setProp(robot, \"readSensor\", vm.getProp(modExports, \"readSensor\"));\n}\n\nfunction setupServo(vm, robot) {\n    vm.evalCode(`\nclass Servo {\n    constructor( pin, timer, channel ){\n        this.pin = pin;\n    }\n\n    write(value){\n        __enabledraw(value > 512);\n    }\n}\n`);\n    const penPos = vm.newObject();\n    vm.setProp(penPos, \"Down\", vm.newNumber(512 + 50));\n    vm.setProp(penPos, \"Up\", vm.newNumber(512 - 180));\n    vm.setProp(penPos, \"Unload\", vm.newNumber(0));\n\n    vm.setProp(robot, \"PenPos\", penPos);\n    penPos.dispose();\n}\n\nfunction setupPins(vm, robot) {\n    const pins = vm.newObject();\n    const sp = (name, val) => {\n        vm.setProp(pins, name, vm.newNumber(val));\n    }\n    sp(\"StatusLED\", 46);\n    sp(\"Motor1A\", 11);\n    sp(\"Motor1B\", 12);\n    sp(\"Motor2A\", 45);\n    sp(\"Motor2B\", 13);\n    sp(\"Enc1A\", 39);\n    sp(\"Enc1B\", 40);\n    sp(\"Enc2A\", 42);\n    sp(\"Enc2B\", 41);\n\n    sp(\"Sens1\", 4);\n    sp(\"Sens2\", 5);\n    sp(\"Sens3\", 6);\n    sp(\"Sens4\", 7);\n\n    sp(\"SensSW\", 8);\n    sp(\"SensEN\", 47);\n    vm.setProp(robot, \"Pins\", pins);\n}\n\nfunction runCode(modules, code) {\n    moduleCache = modules;\n\n    newQuickJSAsyncWASMModule().then(async QuickJS => {\n        const vm = QuickJS.newContext();\n        initializeVM(vm);\n\n        const deadline = Date.now() + 100\n        vm.runtime.setInterruptHandler(shouldInterruptAfterDeadline(deadline))\n        const result = await vm.evalCode(`(async () => {\n${code}\n})()` );\n        vm.runtime.executePendingJobs();\n        if (result.error) {\n            console.log(\"Execution failed:\", vm.getString(result.error));\n            result.error.dispose();\n        } else {\n            console.log(\"Success:\", vm.getString(result.value));\n            result.value.dispose();\n        }\n    });\n    //postMessage()\n}\n","import type { InterruptHandler } from \"./runtime\"\n\n/**\n * Returns an interrupt handler that interrupts Javascript execution after a deadline time.\n *\n * @param deadline - Interrupt execution if it's still running after this time.\n *   Number values are compared against `Date.now()`\n */\nexport function shouldInterruptAfterDeadline(deadline: Date | number): InterruptHandler {\n  const deadlineAsNumber = typeof deadline === \"number\" ? deadline : deadline.getTime()\n\n  return function () {\n    return Date.now() > deadlineAsNumber\n  }\n}\n"],"names":["n","t","e","arguments","Promise","Error","i","JS_EVAL_TYPE_GLOBAL","JS_EVAL_TYPE_MODULE","JS_EVAL_TYPE_DIRECT","JS_EVAL_TYPE_INDIRECT","JS_EVAL_TYPE_MASK","JS_EVAL_FLAG_STRICT","JS_EVAL_FLAG_STRIP","JS_EVAL_FLAG_COMPILE_ONLY","JS_EVAL_FLAG_BACKTRACE_BARRIER","a","BaseObjects","Date","Eval","StringNormalize","RegExp","RegExpCompiler","JSON","Proxy","MapSet","TypedArrays","BigInt","BigFloat","BigDecimal","OperatorOverloading","BignumExt","p","Pending","Fulfilled","Rejected","R","console","log","ee","QuickJSAsyncifyError","k","QuickJSAsyncifySuspended","g","QuickJSEmscriptenModuleError","O","QuickJSMemoryLeakDetected","A","QuickJSNotImplemented","_","QuickJSPromisePending","Q","QuickJSUnknownIntrinsic","P","QuickJSUnwrapError","y","QuickJSUseAfterFree","x","QuickJSWrongOwner","w","constructor","super","String","cause","context","name","TypeError","z","s","L","F","_len","length","Array","_key","V","call","done","value","then","next","throw","of","f","Symbol","dispose","this","U","_Symbol$dispose","for","G","prototype","c","r","_value","copier","disposer","_owner","_alive","_constructorStack","stack","alive","assertAlive","owner","dupable","dup","consume","concat","S","C","I","Object","assign","message","disposeError","h","_disposables","Set","withScope","withScopeMaybeAsync","Y","o","withScopeAsync","manage","add","from","values","reverse","T","resolve","resolveHandle","unwrapResult","callFunction","undefined","disposeResolvers","onSettled","reject","rejectHandle","handle","runtime","promiseHandle","settled","J","module","toPointerArray","Int32Array","map","BYTES_PER_ELEMENT","_malloc","Uint8Array","HEAPU8","buffer","set","_free","newMutablePointerArray","fill","typedArray","ptr","newHeapCharPointer","lengthBytesUTF8","stringToUTF8","strlen","newHeapBufferPointer","byteLength","pointer","numBytes","consumeHeapCharPointer","UTF8ToString","freeze","K","entries","$","q","type","strict","strip","compileOnly","backtraceBarrier","b","W","_len2","_key2","N","_e$ownedLifetimes","scope","copyJSValue","ffi","QTS_DupValuePointer","ctx","freeJSValue","QTS_FreeValuePointer","ownedLifetimes","forEach","rt","consumeJSCharPointer","QTS_FreeCString","heapValueHandle","M","_undefined","_null","_false","_true","_global","_BigInt","fnNextId","fnMaps","Map","cToHostCallbacks","getFunction","l","u","m","memory","H","d","v","QTS_ArgvGetJSValueConstPointer","apply","error","errorToHandle","QTS_Throw","callbacks","setContextCallbacks","dump","bind","getString","getNumber","resolvePromise","QTS_GetUndefined","null","QTS_GetNull","true","QTS_GetTrue","false","QTS_GetFalse","global","QTS_GetGlobalObject","newNumber","QTS_NewFloat64","newString","QTS_NewString","newUniqueSymbol","_ref","description","QTS_NewSymbol","newSymbolFor","_ref2","newBigInt","getProp","newObject","assertOwned","QTS_NewObjectProto","QTS_NewObject","newArray","QTS_NewArray","newArrayBuffer","QTS_NewArrayBuffer","newPromise","QTS_NewPromiseCapability","newError","newFunction","setFunction","QTS_NewFunction","QTS_NewError","setProp","typeof","QTS_Typeof","QTS_GetFloat64","QTS_GetString","getSymbol","QTS_GetSymbolDescriptionOrKey","QTS_IsGlobalSymbol","getBigInt","getArrayBuffer","QTS_GetArrayBufferLength","QTS_GetArrayBuffer","subarray","getPromiseState","QTS_PromiseState","notAPromise","B","QTS_PromiseResult","borrowPropertyKey","QTS_GetProp","QTS_SetProp","defineProp","configurable","enumerable","get","QTS_DefineProp","_len3","_key3","QTS_Call","QTS_ResolveException","evalCode","QTS_Eval","getMemory","QTS_Dump","parse","encodeBinaryJSON","QTS_bjson_encode","decodeBinaryJSON","QTS_bjson_decode","E","_e$ownedLifetimes2","contextMap","shouldInterrupt","interruptHandler","loadModuleSource","_this$contextMap$get","moduleLoader","newContext","contextPointer","normalizeModule","_this$contextMap$get2","moduleNormalizer","setRuntimeCallbacks","executePendingJobs","intrinsics","QTS_NewContext","delete","deleteContext","QTS_FreeContext","setModuleLoader","QTS_RuntimeEnableModuleLoader","removeModuleLoader","QTS_RuntimeDisableModuleLoader","hasPendingJob","QTS_IsJobPending","setInterruptHandler","QTS_RuntimeEnableInterruptHandler","removeInterruptHandler","QTS_RuntimeDisableInterruptHandler","_this$contextMap$get3","QTS_ExecutePendingJob","QTS_FreeValuePointerRuntime","setMemoryLimit","QTS_RuntimeSetMemoryLimit","computeMemoryUsage","getSystemContext","QTS_RuntimeComputeMemoryUsage","dumpMemoryUsage","QTS_RuntimeDumpMemoryUsage","setMaxStackSize","QTS_RuntimeSetMaxStackSize","D","j","contextCallbacks","runtimeCallbacks","suspendedCount","handleAsyncify","deleteRuntime","handleSleep","suspended","ie","maxStackSizeBytes","memoryLimitBytes","ne","X","newRuntime","QTS_NewRuntime","QTS_FreeRuntime","getWasmMemory","_this$module$quickjsE","_this$module","_this$module$quickjsE2","quickjsEmscriptenInit","getFFI","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","__webpack_modules__","definition","key","defineProperty","chunkId","all","keys","reduce","promises","miniCssF","obj","prop","hasOwnProperty","toStringTag","self","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","push","data","chunkIds","moreModules","pop","default","importFFI","QuickJSAsyncFFI","importModuleLoader","QuickJSAsyncWASMModule","moduleCache","output","sensorReadings","velocity","configuredAdc","QuickJSInterval","UsingDisposable","disposeContext","interval","INTERVALS","fnHandle","intervalId","clearInterval","eventListeners","event","payload","addFunction","vm","func","parent","functionHandle","onmessage","action","modules","code","newQuickJSAsyncWASMModule","async","QuickJS","moduleName","on","postMessage","setIntervalHandle","callbackHandle","delayHandle","size","delayMs","longLivedCallbackHandle","setInterval","disposable","setTimeoutHandle","setTimeout","clearIntervalHandle","intervalIdHandle","clearTimeoutHandle","clearTimeout","sleepHandle","ms","promise","setupTimeouts","logHandle","args","nativeArgs","arg","consoleHandle","setupOutput","robot","speed","curve","lRate","rRate","distance","time","duration","angle","setUpMotors","adcHandle","pin","idx","NaN","modExports","setUpSensors","penPos","setupServo","pins","sp","val","setupPins","initializeVM","deadline","now","getTime","shouldInterruptAfterDeadline","result"],"sourceRoot":""}