{"version":3,"file":"static/js/667.c727fe28.chunk.js","mappings":"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","sources":["../node_modules/quickjs-emscripten-core/src/context-asyncify.ts","../node_modules/quickjs-emscripten-core/src/runtime-asyncify.ts","../node_modules/quickjs-emscripten-core/src/module-asyncify.ts"],"sourcesContent":["import type {\n  QuickJSAsyncEmscriptenModule,\n  QuickJSAsyncFFI,\n  EvalDetectModule,\n  EvalFlags,\n  JSRuntimePointer,\n  JSValuePointer,\n} from \"@jitl/quickjs-ffi-types\"\nimport { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport type { Lifetime } from \"./lifetime\"\nimport type { QuickJSModuleCallbacks } from \"./module\"\nimport type { QuickJSAsyncRuntime } from \"./runtime-asyncify\"\nimport type { ContextEvalOptions, QuickJSHandle } from \"./types\"\nimport { evalOptionsToFlags } from \"./types\"\nimport type { VmCallResult } from \"./vm-interface\"\n\nexport type AsyncFunctionImplementation = (\n  this: QuickJSHandle,\n  ...args: QuickJSHandle[]\n) => Promise<QuickJSHandle | VmCallResult<QuickJSHandle> | void>\n\n/**\n * Asyncified version of {@link QuickJSContext}.\n *\n * *Asyncify* allows normally synchronous code to wait for asynchronous Promises\n * or callbacks. The asyncified version of QuickJSContext can wait for async\n * host functions as though they were synchronous.\n */\nexport class QuickJSAsyncContext extends QuickJSContext {\n  public declare runtime: QuickJSAsyncRuntime\n  /** @private */\n  protected declare module: QuickJSAsyncEmscriptenModule\n  /** @private */\n  protected declare ffi: QuickJSAsyncFFI\n  /** @private */\n  protected declare rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected declare callbacks: QuickJSModuleCallbacks\n\n  /**\n   * Asyncified version of {@link evalCode}.\n   */\n  async evalCodeAsync(\n    code: string,\n    filename: string = \"eval.js\",\n    /** See {@link EvalFlags} for number semantics */\n    options?: number | ContextEvalOptions,\n  ): Promise<VmCallResult<QuickJSHandle>> {\n    const detectModule = (options === undefined ? 1 : 0) as EvalDetectModule\n    const flags = evalOptionsToFlags(options) as EvalFlags\n    let resultPtr = 0 as JSValuePointer\n    try {\n      resultPtr = await this.memory\n        .newHeapCharPointer(code)\n        .consume((charHandle) =>\n          this.ffi.QTS_Eval_MaybeAsync(\n            this.ctx.value,\n            charHandle.value.ptr,\n            charHandle.value.strlen,\n            filename,\n            detectModule,\n            flags,\n          ),\n        )\n    } catch (error) {\n      debugLog(\"QTS_Eval_MaybeAsync threw\", error)\n      throw error\n    }\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Similar to {@link newFunction}.\n   * Convert an async host Javascript function into a synchronous QuickJS function value.\n   *\n   * Whenever QuickJS calls this function, the VM's stack will be unwound while\n   * waiting the async function to complete, and then restored when the returned\n   * promise resolves.\n   *\n   * Asyncified functions must never call other asyncified functions or\n   * `import`, even indirectly, because the stack cannot be unwound twice.\n   *\n   * See [Emscripten's docs on Asyncify](https://emscripten.org/docs/porting/asyncify.html).\n   */\n  newAsyncifiedFunction(name: string, fn: AsyncFunctionImplementation): QuickJSHandle {\n    return this.newFunction(name, fn as any)\n  }\n}\n","import type {\n  QuickJSAsyncEmscriptenModule,\n  QuickJSAsyncFFI,\n  JSContextPointer,\n  JSRuntimePointer,\n} from \"@jitl/quickjs-ffi-types\"\nimport { QuickJSAsyncContext } from \"./context-asyncify\"\nimport type {\n  // Used in doc\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  QuickJSAsyncWASMModule,\n} from \"./module-asyncify\"\nimport type { QuickJSModuleCallbacks } from \"./module\"\nimport { QuickJSRuntime } from \"./runtime\"\nimport type {\n  ContextOptions,\n  JSModuleLoader,\n  JSModuleLoaderAsync,\n  JSModuleNormalizer,\n  JSModuleNormalizerAsync,\n} from \"./types\"\nimport { intrinsicsToFlags } from \"./types\"\nimport { Lifetime } from \"./lifetime\"\n\nexport class QuickJSAsyncRuntime extends QuickJSRuntime {\n  public declare context: QuickJSAsyncContext | undefined\n\n  /** @private */\n  protected declare module: QuickJSAsyncEmscriptenModule\n  /** @private */\n  protected declare ffi: QuickJSAsyncFFI\n  /** @private */\n  protected declare rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected declare callbacks: QuickJSModuleCallbacks\n  /** @private */\n  protected declare contextMap: Map<JSContextPointer, QuickJSAsyncContext>\n\n  /** @private */\n  constructor(args: {\n    module: QuickJSAsyncEmscriptenModule\n    ffi: QuickJSAsyncFFI\n    rt: Lifetime<JSRuntimePointer>\n    callbacks: QuickJSModuleCallbacks\n  }) {\n    super(args)\n  }\n\n  override newContext(options: ContextOptions = {}): QuickJSAsyncContext {\n    const intrinsics = intrinsicsToFlags(options.intrinsics)\n    const ctx = new Lifetime(\n      this.ffi.QTS_NewContext(this.rt.value, intrinsics),\n      undefined,\n      (ctx_ptr) => {\n        this.contextMap.delete(ctx_ptr)\n        this.callbacks.deleteContext(ctx_ptr)\n        this.ffi.QTS_FreeContext(ctx_ptr)\n      },\n    )\n\n    const context = new QuickJSAsyncContext({\n      module: this.module,\n      ctx,\n      ffi: this.ffi,\n      rt: this.rt,\n      ownedLifetimes: [],\n      runtime: this,\n      callbacks: this.callbacks,\n    })\n    this.contextMap.set(ctx.value, context)\n\n    return context\n  }\n\n  public override setModuleLoader(\n    moduleLoader: JSModuleLoaderAsync,\n    moduleNormalizer?: JSModuleNormalizerAsync,\n  ): void {\n    super.setModuleLoader(\n      moduleLoader as JSModuleLoader,\n      moduleNormalizer as JSModuleNormalizer | undefined,\n    )\n  }\n\n  /**\n   * Set the max stack size for this runtime in bytes.\n   * To remove the limit, set to `0`.\n   *\n   * Setting this limit also adjusts the global `ASYNCIFY_STACK_SIZE` for the entire {@link QuickJSAsyncWASMModule}.\n   * See the [pull request](https://github.com/justjake/quickjs-emscripten/pull/114) for more details.\n   */\n  public override setMaxStackSize(stackSize: number): void {\n    return super.setMaxStackSize(stackSize)\n  }\n}\n","import type { QuickJSAsyncEmscriptenModule, QuickJSAsyncFFI } from \"@jitl/quickjs-ffi-types\"\nimport type { QuickJSAsyncContext } from \"./context-asyncify\"\nimport { QuickJSNotImplemented } from \"./errors\"\nimport { Lifetime, Scope } from \"./lifetime\"\nimport type { ModuleEvalOptions } from \"./module\"\nimport { applyBaseRuntimeOptions, applyModuleEvalRuntimeOptions, QuickJSWASMModule } from \"./module\"\nimport { QuickJSAsyncRuntime } from \"./runtime-asyncify\"\nimport type { AsyncRuntimeOptions, ContextOptions } from \"./types\"\n\n/**\n * Asyncified version of {@link QuickJSWASMModule}.\n *\n * Due to limitations of Emscripten's ASYNCIFY process, only a single async\n * function call can happen at a time across the entire WebAssembly module.\n *\n * That means that all runtimes, contexts, functions, etc created inside this\n * WebAssembly are limited to a single concurrent async action.\n * **Multiple concurrent async actions is an error.**\n *\n * To allow for multiple concurrent async actions, you must create multiple WebAssembly\n * modules.\n */\nexport class QuickJSAsyncWASMModule extends QuickJSWASMModule {\n  /** @private */\n  protected ffi: QuickJSAsyncFFI\n  /** @private */\n  protected module: QuickJSAsyncEmscriptenModule\n\n  /** @private */\n  constructor(module: QuickJSAsyncEmscriptenModule, ffi: QuickJSAsyncFFI) {\n    super(module, ffi)\n    this.ffi = ffi\n    this.module = module\n  }\n\n  /**\n   * Create a new async runtime inside this WebAssembly module. All runtimes inside a\n   * module are limited to a single async call at a time. For multiple\n   * concurrent async actions, create multiple WebAssembly modules.\n   */\n  override newRuntime(options: AsyncRuntimeOptions = {}): QuickJSAsyncRuntime {\n    const rt = new Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr) => {\n      this.callbacks.deleteRuntime(rt_ptr)\n      this.ffi.QTS_FreeRuntime(rt_ptr)\n    })\n    const runtime = new QuickJSAsyncRuntime({\n      module: this.module,\n      ffi: this.ffi,\n      rt,\n      callbacks: this.callbacks,\n    })\n\n    applyBaseRuntimeOptions(runtime, options)\n\n    if (options.moduleLoader) {\n      runtime.setModuleLoader(options.moduleLoader)\n    }\n\n    return runtime\n  }\n\n  /**\n   * A simplified API to create a new {@link QuickJSAsyncRuntime} and a\n   * {@link QuickJSAsyncContext} inside that runtime at the same time. The runtime will\n   * be disposed when the context is disposed.\n   */\n  override newContext(options: ContextOptions = {}): QuickJSAsyncContext {\n    const runtime = this.newRuntime()\n    const lifetimes = options.ownedLifetimes ? options.ownedLifetimes.concat([runtime]) : [runtime]\n    const context = runtime.newContext({ ...options, ownedLifetimes: lifetimes })\n    runtime.context = context\n    return context\n  }\n\n  /** Synchronous evalCode is not supported. */\n  override evalCode(): never {\n    throw new QuickJSNotImplemented(\"QuickJSWASMModuleAsyncify.evalCode: use evalCodeAsync instead\")\n  }\n\n  /**\n   * One-off evaluate code without needing to create a {@link QuickJSAsyncRuntime} or\n   * {@link QuickJSAsyncContext} explicitly.\n   *\n   * This version allows for asynchronous Ecmascript module loading.\n   *\n   * Note that only a single async action can occur at a time inside the entire WebAssembly module.\n   * **Multiple concurrent async actions is an error.**\n   *\n   * See the documentation for {@link QuickJSWASMModule#evalCode} for more details.\n   */\n  evalCodeAsync(code: string, options: ModuleEvalOptions): Promise<unknown> {\n    // TODO: we should really figure out generator for the Promise monad...\n    return Scope.withScopeAsync(async (scope) => {\n      const vm = scope.manage(this.newContext())\n      applyModuleEvalRuntimeOptions(vm.runtime, options)\n      const result = await vm.evalCodeAsync(code, \"eval.js\")\n\n      if (options.memoryLimitBytes !== undefined) {\n        // Remove memory limit so we can dump the result without exceeding it.\n        vm.runtime.setMemoryLimit(-1)\n      }\n\n      if (result.error) {\n        const error = vm.dump(scope.manage(result.error))\n        throw error\n      }\n\n      const value = vm.dump(scope.manage(result.value))\n      return value\n    })\n  }\n}\n"],"names":["u","k","evalCodeAsync","n","e","arguments","length","undefined","t","o","i","S","r","this","memory","newHeapCharPointer","consume","c","ffi","QTS_Eval_MaybeAsync","ctx","value","ptr","strlen","d","a","QTS_ResolveException","QTS_FreeValuePointer","error","heapValueHandle","newAsyncifiedFunction","newFunction","l","J","constructor","super","newContext","y","intrinsics","s","QTS_NewContext","rt","contextMap","delete","callbacks","deleteContext","QTS_FreeContext","module","ownedLifetimes","runtime","set","setModuleLoader","setMaxStackSize","M","A","newRuntime","QTS_NewRuntime","deleteRuntime","QTS_FreeRuntime","Q","moduleLoader","concat","context","evalCode","p","f","withScopeAsync","async","manage","v","memoryLimitBytes","setMemoryLimit","dump"],"sourceRoot":""}